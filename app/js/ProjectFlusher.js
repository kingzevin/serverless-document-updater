// Generated by CoffeeScript 1.7.1
(function() {
  var ProjectFlusher, ProjectManager, RedisManager, Settings, async, docUpdaterKeys, logger, rclient, request, _;

  request = require("request");

  Settings = require('settings-sharelatex');

  RedisManager = require("./RedisManager");

  rclient = RedisManager.rclient;

  docUpdaterKeys = Settings.redis.documentupdater.key_schema;

  async = require("async");

  ProjectManager = require("./ProjectManager");

  _ = require("lodash");

  logger = require("logger-sharelatex");

  ProjectFlusher = {
    _getKeys: function(pattern, limit, callback) {
      var doKeyLookupForNode, nodes;
      nodes = (typeof rclient.nodes === "function" ? rclient.nodes('master') : void 0) || [rclient];
      doKeyLookupForNode = function(node, cb) {
        return ProjectFlusher._getKeysFromNode(node, pattern, limit, cb);
      };
      return async.concatSeries(nodes, doKeyLookupForNode, callback);
    },
    _getKeysFromNode: function(node, pattern, limit, callback) {
      var batchSize, cursor, doIteration, keySet;
      if (limit == null) {
        limit = 1000;
      }
      cursor = 0;
      keySet = {};
      batchSize = limit != null ? Math.min(limit, 1000) : 1000;
      doIteration = function(cb) {
        return node.scan(cursor, "MATCH", pattern, "COUNT", batchSize, function(error, reply) {
          var key, keys, limitReached, noResults, _i, _len;
          if (error != null) {
            return callback(error);
          }
          cursor = reply[0], keys = reply[1];
          for (_i = 0, _len = keys.length; _i < _len; _i++) {
            key = keys[_i];
            keySet[key] = true;
          }
          keys = Object.keys(keySet);
          noResults = cursor === "0";
          limitReached = (limit != null) && keys.length >= limit;
          if (noResults || limitReached) {
            return callback(null, keys);
          } else {
            return setTimeout(doIteration, 10);
          }
        });
      };
      return doIteration();
    },
    _extractIds: function(keyList) {
      var ids, key, m;
      ids = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = keyList.length; _i < _len; _i++) {
          key = keyList[_i];
          m = key.match(/:\{?([0-9a-f]{24})\}?/);
          _results.push(m[1]);
        }
        return _results;
      })();
      return ids;
    },
    flushAllProjects: function(options, callback) {
      logger.log({
        options: options
      }, "flushing all projects");
      return ProjectFlusher._getKeys(docUpdaterKeys.docsInProject({
        project_id: "*"
      }), options.limit, function(error, project_keys) {
        var jobs, project_ids;
        if (error != null) {
          logger.err({
            err: error
          }, "error getting keys for flushing");
          return callback(error);
        }
        project_ids = ProjectFlusher._extractIds(project_keys);
        if (options.dryRun) {
          return callback(null, project_ids);
        }
        jobs = _.map(project_ids, function(project_id) {
          return function(cb) {
            return ProjectManager.flushAndDeleteProjectWithLocks(project_id, {
              background: true
            }, cb);
          };
        });
        return async.parallelLimit(async.reflectAll(jobs), options.concurrency, function(error, results) {
          var failure, success;
          success = [];
          failure = [];
          _.each(results, function(result, i) {
            if (result.error != null) {
              return failure.push(project_ids[i]);
            } else {
              return success.push(project_ids[i]);
            }
          });
          logger.log({
            success: success,
            failure: failure
          }, "finished flushing all projects");
          return callback(error, {
            success: success,
            failure: failure
          });
        });
      });
    }
  };

  module.exports = ProjectFlusher;

}).call(this);

//# sourceMappingURL=ProjectFlusher.map
