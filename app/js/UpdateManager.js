// Generated by CoffeeScript 1.7.1
(function() {
  var DocumentManager, Errors, HistoryManager, LockManager, Metrics, Profiler, RangesManager, RealTimeRedisManager, RedisManager, Settings, ShareJsUpdateManager, SnapshotManager, UpdateManager, async, logger, _,
    __slice = [].slice;

  const TDMap = require('./TDMap'); // zevin: for timestamps

  LockManager = require("./LockManager");

  RedisManager = require("./RedisManager");

  RealTimeRedisManager = require("./RealTimeRedisManager");

  ShareJsUpdateManager = require("./ShareJsUpdateManager");

  HistoryManager = require("./HistoryManager");

  Settings = require('settings-sharelatex');

  _ = require("lodash");

  async = require("async");

  logger = require('logger-sharelatex');

  Metrics = require("./Metrics");

  Errors = require("./Errors");

  DocumentManager = require("./DocumentManager");

  RangesManager = require("./RangesManager");

  SnapshotManager = require("./SnapshotManager");

  Profiler = require("./Profiler");

  module.exports = UpdateManager = {
    processOutstandingUpdates: function(project_id, doc_id, callback) {
      var timer;
      if (callback == null) {
        callback = function(error) {};
      }
      timer = new Metrics.Timer("updateManager.processOutstandingUpdates");
      return UpdateManager.fetchAndApplyUpdates(project_id, doc_id, function(error) {
        timer.done();
        if (error != null) {
          return callback(error);
        }
        return callback();
      });
    },
    processOutstandingUpdatesWithLock: function(project_id, doc_id, callback) {
      var profile;
      if (callback == null) {
        callback = function(error) {};
      }
      profile = new Profiler("processOutstandingUpdatesWithLock", {
        project_id: project_id,
        doc_id: doc_id
      });
      return LockManager.tryLock(doc_id, (function(_this) {
        return function(error, gotLock, lockValue) {
          if (error != null) {
            return callback(error);
          }
          if (!gotLock) {
            return callback();
          }
          profile.log("tryLock");
          return UpdateManager.processOutstandingUpdates(project_id, doc_id, function(error) {
            if (error != null) {
              return UpdateManager._handleErrorInsideLock(doc_id, lockValue, error, callback);
            }
            profile.log("processOutstandingUpdates");
            return LockManager.releaseLock(doc_id, lockValue, (function(_this) {
              return function(error) {
                if (error != null) {
                  return callback(error);
                }
                profile.log("releaseLock").end();
                return UpdateManager.continueProcessingUpdatesWithLock(project_id, doc_id, callback);
              };
            })(this));
          });
        };
      })(this));
    },
    continueProcessingUpdatesWithLock: function(project_id, doc_id, callback) {
      if (callback == null) {
        callback = function(error) {};
      }
      return RealTimeRedisManager.getUpdatesLength(doc_id, (function(_this) {
        return function(error, length) {
          if (error != null) {
            return callback(error);
          }
          if (length > 0) {
            return UpdateManager.processOutstandingUpdatesWithLock(project_id, doc_id, callback);
          } else {
            return callback();
          }
        };
      })(this));
    },
    fetchAndApplyUpdates: function(project_id, doc_id, callback) {
      var profile;
      if (callback == null) {
        callback = function(error) {};
      }
      profile = new Profiler("fetchAndApplyUpdates", {
        project_id: project_id,
        doc_id: doc_id
      });
      return RealTimeRedisManager.getPendingUpdatesForDoc(doc_id, (function(_this) {
        return function(error, updates) {
          var doUpdate, finalCallback;
          if (error != null) {
            return callback(error);
          }
          logger.log({
            project_id: project_id,
            doc_id: doc_id,
            count: updates.length
          }, "processing updates");
          if (updates.length === 0) {
            return callback();
          }
          profile.log("getPendingUpdatesForDoc");
          doUpdate = function(update, cb) {
            // zevin: TD2
            const NS_PER_SEC = 1e9;
            var TD2 = process.hrtime();
            var msTD2 = Date.now();
            version = update.v;
            logger.log({TD2: TD2[0]*NS_PER_SEC+TD2[1], msTD2: msTD2, update_v: version}, 'Zevin: TD2');
            TDMap.initMapIfNotExists('TD2')
            TDMap.initMapIfNotExists('msTD2')
            TDMap.setValue('TD2', `${version}`, TD2[0]*NS_PER_SEC+TD2[1]);
            TDMap.setValue('msTD2', `${version}`, msTD2);
            return UpdateManager.applyUpdate(project_id, doc_id, update, function(err) {
              profile.log("applyUpdate");
              return cb(err);
            });
          };
          finalCallback = function(err) {
            profile.log("async done").end();
            return callback(err);
          };
          return async.eachSeries(updates, doUpdate, finalCallback);
        };
      })(this));
    },
    applyUpdate: function(project_id, doc_id, update, _callback) {
      var callback, profile;
      if (_callback == null) {
        _callback = function(error) {};
      }
      callback = function(error) {
        if (error != null) {
          RealTimeRedisManager.sendData({
            project_id: project_id,
            doc_id: doc_id,
            error: error.message || error
          });
          profile.log("sendData");
        }
        profile.end();
        return _callback(error);
      };
      profile = new Profiler("applyUpdate", {
        project_id: project_id,
        doc_id: doc_id
      });
      UpdateManager._sanitizeUpdate(update);
      profile.log("sanitizeUpdate");
      return DocumentManager.getDoc(project_id, doc_id, function(error, lines, version, ranges, pathname, projectHistoryId) {
        var previousVersion;
        profile.log("getDoc");
        if (error != null) {
          return callback(error);
        }
        if ((lines == null) || (version == null)) {
          return callback(new Errors.NotFoundError("document not found: " + doc_id));
        }
        previousVersion = version;
        return ShareJsUpdateManager.applyUpdate(project_id, doc_id, update, lines, version, function(error, updatedDocLines, version, appliedOps) {
          profile.log("sharejs.applyUpdate");
          if (error != null) {
            return callback(error);
          }
          return RangesManager.applyUpdate(project_id, doc_id, ranges, appliedOps, updatedDocLines, function(error, new_ranges, ranges_were_collapsed) {
            UpdateManager._addProjectHistoryMetadataToOps(appliedOps, pathname, projectHistoryId, lines);
            profile.log("RangesManager.applyUpdate");
            if (error != null) {
              return callback(error);
            }
            return RedisManager.updateDocument(project_id, doc_id, updatedDocLines, version, appliedOps, new_ranges, update.meta, function(error, doc_ops_length, project_ops_length) {
              profile.log("RedisManager.updateDocument");
              if (error != null) {
                return callback(error);
              }
              return HistoryManager.recordAndFlushHistoryOps(project_id, doc_id, appliedOps, doc_ops_length, project_ops_length, function(error) {
                profile.log("recordAndFlushHistoryOps");
                if (error != null) {
                  return callback(error);
                }
                if (ranges_were_collapsed) {
                  logger.log({
                    project_id: project_id,
                    doc_id: doc_id,
                    previousVersion: previousVersion,
                    lines: lines,
                    ranges: ranges,
                    update: update
                  }, "update collapsed some ranges, snapshotting previous content");
                  return SnapshotManager.recordSnapshot(project_id, doc_id, previousVersion, pathname, lines, ranges, function(error) {
                    if (error != null) {
                      logger.error({
                        err: error,
                        project_id: project_id,
                        doc_id: doc_id,
                        version: version,
                        lines: lines,
                        ranges: ranges
                      }, "error recording snapshot");
                      return callback(error);
                    } else {
                      return callback();
                    }
                  });
                } else {
                  return callback();
                }
              });
            });
          });
        });
      });
    },
    lockUpdatesAndDo: function() {
      var args, callback, doc_id, method, profile, project_id, _i;
      method = arguments[0], project_id = arguments[1], doc_id = arguments[2], args = 5 <= arguments.length ? __slice.call(arguments, 3, _i = arguments.length - 1) : (_i = 3, []), callback = arguments[_i++];
      profile = new Profiler("lockUpdatesAndDo", {
        project_id: project_id,
        doc_id: doc_id
      });
      return LockManager.getLock(doc_id, function(error, lockValue) {
        profile.log("getLock");
        if (error != null) {
          return callback(error);
        }
        return UpdateManager.processOutstandingUpdates(project_id, doc_id, function(error) {
          if (error != null) {
            return UpdateManager._handleErrorInsideLock(doc_id, lockValue, error, callback);
          }
          profile.log("processOutstandingUpdates");
          return method.apply(null, [project_id, doc_id].concat(__slice.call(args), [function() {
            var error, response_args;
            error = arguments[0], response_args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
            if (error != null) {
              return UpdateManager._handleErrorInsideLock(doc_id, lockValue, error, callback);
            }
            profile.log("method");
            return LockManager.releaseLock(doc_id, lockValue, function(error) {
              if (error != null) {
                return callback(error);
              }
              profile.log("releaseLock").end();
              callback.apply(null, [null].concat(__slice.call(response_args)));
              return UpdateManager.continueProcessingUpdatesWithLock(project_id, doc_id);
            });
          }]));
        });
      });
    },
    _handleErrorInsideLock: function(doc_id, lockValue, original_error, callback) {
      if (callback == null) {
        callback = function(error) {};
      }
      return LockManager.releaseLock(doc_id, lockValue, function(lock_error) {
        return callback(original_error);
      });
    },
    _sanitizeUpdate: function(update) {
      var op, _i, _len, _ref;
      _ref = update.op || [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        op = _ref[_i];
        if (op.i != null) {
          op.i = op.i.replace(/[\uD800-\uDFFF]/g, "\uFFFD");
        }
      }
      return update;
    },
    _addProjectHistoryMetadataToOps: function(updates, pathname, projectHistoryId, lines) {
      var doc_length;
      doc_length = _.reduce(lines, function(chars, line) {
        return chars + line.length;
      }, 0);
      doc_length += lines.length - 1;
      return updates.forEach(function(update) {
        var op, _i, _len, _ref, _results;
        update.projectHistoryId = projectHistoryId;
        update.meta || (update.meta = {});
        update.meta.pathname = pathname;
        update.meta.doc_length = doc_length;
        _ref = update.op;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          op = _ref[_i];
          if (op.i != null) {
            doc_length += op.i.length;
          }
          if (op.d != null) {
            _results.push(doc_length -= op.d.length);
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      });
    }
  };

}).call(this);

//# sourceMappingURL=UpdateManager.map
