
// Generated by CoffeeScript 1.7.1
(function() {
  var DeleteQueueManager, DocumentManager, Errors, HistoryManager, HttpController, Metrics, ProjectFlusher, ProjectManager, TWO_MEGABYTES, async, logger;

  DocumentManager = require("./DocumentManager");

  HistoryManager = require("./HistoryManager");

  ProjectManager = require("./ProjectManager");

  Errors = require("./Errors");

  logger = require("logger-sharelatex");

  Metrics = require("./Metrics");

  ProjectFlusher = require("./ProjectFlusher");

  DeleteQueueManager = require("./DeleteQueueManager");

  async = require("async");

  TWO_MEGABYTES = 2 * 1024 * 1024;

  module.exports = HttpController = {
    getDoc: function(req, res, next) {
      var doc_id, fromVersion, project_id, timer, _ref;
      if (next == null) {
        next = function(error) {};
      }
      doc_id = req.params.doc_id;
      project_id = req.params.project_id;
      logger.log({
        project_id: project_id,
        doc_id: doc_id
      }, "getting doc via http");
      timer = new Metrics.Timer("http.getDoc");
      if (((_ref = req.query) != null ? _ref.fromVersion : void 0) != null) {
        fromVersion = parseInt(req.query.fromVersion, 10);
      } else {
        fromVersion = -1;
      }
      return DocumentManager.getDocAndRecentOpsWithLock(project_id, doc_id, fromVersion, function(error, lines, version, ops, ranges, pathname) {
        timer.done();
        if (error != null) {
          res.sendStatus(500);
          return next(error);
        }
        logger.log({
          project_id: project_id,
          doc_id: doc_id
        }, "got doc via http");
        if ((lines == null) || (version == null)) {
          return next(new Errors.NotFoundError("document not found"));
        }
        return res.json({
          id: doc_id,
          lines: lines,
          version: version,
          ops: ops,
          ranges: ranges,
          pathname: pathname
        });
      });
    },
    _getTotalSizeOfLines: function(lines) {
      var line, size, _i, _len;
      size = 0;
      for (_i = 0, _len = lines.length; _i < _len; _i++) {
        line = lines[_i];
        size += line.length + 1;
      }
      return size;
    },
    getProjectDocsAndFlushIfOld: function(req, res, next) {
      var excludeItems, excludeVersions, id, item, projectStateHash, project_id, timer, version, _i, _len, _ref, _ref1, _ref2, _ref3;
      if (next == null) {
        next = function(error) {};
      }
      project_id = req.params.project_id;
      projectStateHash = (_ref = req.query) != null ? _ref.state : void 0;
      excludeItems = ((_ref1 = req.query) != null ? (_ref2 = _ref1.exclude) != null ? _ref2.split(',') : void 0 : void 0) || [];
      logger.log({
        project_id: project_id,
        exclude: excludeItems
      }, "getting docs via http");
      timer = new Metrics.Timer("http.getAllDocs");
      excludeVersions = {};
      for (_i = 0, _len = excludeItems.length; _i < _len; _i++) {
        item = excludeItems[_i];
        _ref3 = item != null ? item.split(':') : void 0, id = _ref3[0], version = _ref3[1];
        excludeVersions[id] = version;
      }
      logger.log({
        project_id: project_id,
        projectStateHash: projectStateHash,
        excludeVersions: excludeVersions
      }, "excluding versions");
      return ProjectManager.getProjectDocsAndFlushIfOld(project_id, projectStateHash, excludeVersions, function(error, result) {
        var doc;
        timer.done();
        if (error instanceof Errors.ProjectStateChangedError) {
          return res.send(409);
        } else if (error != null) {
          res.sendStatus(500);
          return next(error);
        } else {
          logger.log({
            project_id: project_id,
            result: (function() {
              var _j, _len1, _results;
              _results = [];
              for (_j = 0, _len1 = result.length; _j < _len1; _j++) {
                doc = result[_j];
                _results.push("" + doc._id + ":" + doc.v);
              }
              return _results;
            })()
          }, "got docs via http");
          return res.send(result);
        }
      });
    },
    clearProjectState: function(req, res, next) {
      var project_id, timer;
      if (next == null) {
        next = function(error) {};
      }
      project_id = req.params.project_id;
      timer = new Metrics.Timer("http.clearProjectState");
      logger.log({
        project_id: project_id
      }, "clearing project state via http");
      return ProjectManager.clearProjectState(project_id, function(error) {
        timer.done();
        if (error != null) {
          res.sendStatus(500);
          return next(error);
        } else {
          return res.send(200);
        }
      });
    },
    setDoc: function(req, res, next) {
      var doc_id, lineSize, lines, project_id, source, timer, undoing, user_id, _ref;
      if (next == null) {
        next = function(error) {};
      }
      doc_id = req.params.doc_id;
      project_id = req.params.project_id;
      _ref = req.body, lines = _ref.lines, source = _ref.source, user_id = _ref.user_id, undoing = _ref.undoing;
      lineSize = HttpController._getTotalSizeOfLines(lines);
      if (lineSize > TWO_MEGABYTES) {
        logger.log({
          project_id: project_id,
          doc_id: doc_id,
          source: source,
          lineSize: lineSize,
          user_id: user_id
        }, "document too large, returning 406 response");
        return res.send(406);
      }
      logger.log({
        project_id: project_id,
        doc_id: doc_id,
        lines: lines,
        source: source,
        user_id: user_id,
        undoing: undoing
      }, "setting doc via http");
      timer = new Metrics.Timer("http.setDoc");
      return DocumentManager.setDocWithLock(project_id, doc_id, lines, source, user_id, undoing, function(error) {
        timer.done();
        if (error != null) {
          res.sendStatus(500);
          return next(error);
        }
        logger.log({
          project_id: project_id,
          doc_id: doc_id
        }, "set doc via http");
        return res.send(204);
      });
    },
    flushDocIfLoaded: function(req, res, next) {
      var doc_id, project_id, timer;
      if (next == null) {
        next = function(error) {};
      }
      doc_id = req.params.doc_id;
      project_id = req.params.project_id;
      logger.log({
        project_id: project_id,
        doc_id: doc_id
      }, "flushing doc via http");
      timer = new Metrics.Timer("http.flushDoc");
      return DocumentManager.flushDocIfLoadedWithLock(project_id, doc_id, function(error) {
        timer.done();
        if (error != null) {
          res.sendStatus(500);
          return next(error);
        }
        logger.log({
          project_id: project_id,
          doc_id: doc_id
        }, "flushed doc via http");
        return res.send(204);
      });
    },
    flushAndDeleteDoc: function(req, res, next) {
      var doc_id, project_id, timer;
      if (next == null) {
        next = function(error) {};
      }
      doc_id = req.params.doc_id;
      project_id = req.params.project_id;
      logger.log({
        project_id: project_id,
        doc_id: doc_id
      }, "deleting doc via http");
      timer = new Metrics.Timer("http.deleteDoc");
      return DocumentManager.flushAndDeleteDocWithLock(project_id, doc_id, function(error) {
        timer.done();
        HistoryManager.flushProjectChangesAsync(project_id);
        if (error != null) {
          res.sendStatus(500);
          return next(error);
        }
        logger.log({
          project_id: project_id,
          doc_id: doc_id
        }, "deleted doc via http");
        return res.send(204);
      });
    },
    flushProject: function(req, res, next) {
      var project_id, timer;
      if (next == null) {
        next = function(error) {};
      }
      project_id = req.params.project_id;
      logger.log({
        project_id: project_id
      }, "flushing project via http");
      timer = new Metrics.Timer("http.flushProject");
      return ProjectManager.flushProjectWithLocks(project_id, function(error) {
        timer.done();
        if (error != null) {
          res.sendStatus(500);
          return next(error);
        }
        logger.log({
          project_id: project_id
        }, "flushed project via http");
        return res.send(204);
      });
    },
    deleteProject: function(req, res, next) {
      var options, project_id, timer, _ref, _ref1, _ref2;
      if (next == null) {
        next = function(error) {};
      }
      project_id = req.params.project_id;
      logger.log({
        project_id: project_id
      }, "deleting project via http");
      options = {};
      if ((_ref = req.query) != null ? _ref.background : void 0) {
        options.background = true;
      }
      if ((_ref1 = req.query) != null ? _ref1.shutdown : void 0) {
        options.skip_history_flush = true;
      }
      if ((_ref2 = req.query) != null ? _ref2.background : void 0) {
        return ProjectManager.queueFlushAndDeleteProject(project_id, function(error) {
          if (error != null) {
            res.sendStatus(500);
            return next(error);
          }
          logger.log({
            project_id: project_id
          }, "queue delete of project via http");
          return res.send(204);
        });
      } else {
        timer = new Metrics.Timer("http.deleteProject");
        return ProjectManager.flushAndDeleteProjectWithLocks(project_id, options, function(error) {
          timer.done();
          if (error != null) {
            res.sendStatus(500);
            return next(error);
          }
          logger.log({
            project_id: project_id
          }, "deleted project via http");
          return res.send(204);
        });
      }
    },
    deleteMultipleProjects: function(req, res, next) {
      var project_ids, _ref;
      if (next == null) {
        next = function(error) {};
      }
      project_ids = ((_ref = req.body) != null ? _ref.project_ids : void 0) || [];
      logger.log({
        project_ids: project_ids
      }, "deleting multiple projects via http");
      return async.eachSeries(project_ids, function(project_id, cb) {
        logger.log({
          project_id: project_id
        }, "queue delete of project via http");
        return ProjectManager.queueFlushAndDeleteProject(project_id, cb);
      }, function(error) {
        if (error != null) {
          res.sendStatus(500);
          return next(error);
        }
        return res.send(204);
      });
    },
    acceptChanges: function(req, res, next) {
      var change_ids, doc_id, project_id, timer, _ref, _ref1;
      if (next == null) {
        next = function(error) {};
      }
      _ref = req.params, project_id = _ref.project_id, doc_id = _ref.doc_id;
      change_ids = (_ref1 = req.body) != null ? _ref1.change_ids : void 0;
      if (change_ids == null) {
        change_ids = [req.params.change_id];
      }
      logger.log({
        project_id: project_id,
        doc_id: doc_id
      }, "accepting " + change_ids.length + " changes via http");
      timer = new Metrics.Timer("http.acceptChanges");
      return DocumentManager.acceptChangesWithLock(project_id, doc_id, change_ids, function(error) {
        timer.done();
        if (error != null) {
          res.sendStatus(500);
          return next(error);
        }
        logger.log({
          project_id: project_id,
          doc_id: doc_id
        }, "accepted " + change_ids.length + " changes via http");
        return res.send(204);
      });
    },
    deleteComment: function(req, res, next) {
      var comment_id, doc_id, project_id, timer, _ref;
      if (next == null) {
        next = function(error) {};
      }
      _ref = req.params, project_id = _ref.project_id, doc_id = _ref.doc_id, comment_id = _ref.comment_id;
      logger.log({
        project_id: project_id,
        doc_id: doc_id,
        comment_id: comment_id
      }, "deleting comment via http");
      timer = new Metrics.Timer("http.deleteComment");
      return DocumentManager.deleteCommentWithLock(project_id, doc_id, comment_id, function(error) {
        timer.done();
        if (error != null) {
          res.sendStatus(500);
          return next(error);
        }
        logger.log({
          project_id: project_id,
          doc_id: doc_id,
          comment_id: comment_id
        }, "deleted comment via http");
        return res.send(204);
      });
    },
    updateProject: function(req, res, next) {
      var docUpdates, fileUpdates, projectHistoryId, project_id, timer, userId, version, _ref;
      if (next == null) {
        next = function(error) {};
      }
      timer = new Metrics.Timer("http.updateProject");
      project_id = req.params.project_id;
      _ref = req.body, projectHistoryId = _ref.projectHistoryId, userId = _ref.userId, docUpdates = _ref.docUpdates, fileUpdates = _ref.fileUpdates, version = _ref.version;
      logger.log({
        project_id: project_id,
        docUpdates: docUpdates,
        fileUpdates: fileUpdates,
        version: version
      }, "updating project via http");
      return ProjectManager.updateProjectWithLocks(project_id, projectHistoryId, userId, docUpdates, fileUpdates, version, function(error) {
        timer.done();
        if (error != null) {
          res.sendStatus(500);
          return next(error);
        }
        logger.log({
          project_id: project_id
        }, "updated project via http");
        return res.send(204);
      });
    },
    resyncProjectHistory: function(req, res, next) {
      var docs, files, projectHistoryId, project_id, _ref;
      if (next == null) {
        next = function(error) {};
      }
      project_id = req.params.project_id;
      _ref = req.body, projectHistoryId = _ref.projectHistoryId, docs = _ref.docs, files = _ref.files;
      logger.log({
        project_id: project_id,
        docs: docs,
        files: files
      }, "queuing project history resync via http");
      return HistoryManager.resyncProjectHistory(project_id, projectHistoryId, docs, files, function(error) {
        if (error != null) {
          res.sendStatus(500);
          return next(error);
        }
        logger.log({
          project_id: project_id
        }, "queued project history resync via http");
        return res.send(204);
      });
    },
    flushAllProjects: function(req, res, next) {
      var options;
      if (next == null) {
        next = function(error) {};
      }
      res.setTimeout(5 * 60 * 1000);
      options = {
        limit: req.query.limit || 1000,
        concurrency: req.query.concurrency || 5,
        dryRun: req.query.dryRun || false
      };
      return ProjectFlusher.flushAllProjects(options, function(err, project_ids) {
        if (err != null) {
          logger.err({
            err: err
          }, "error bulk flushing projects");
          return res.send(500);
        } else {
          return res.send(project_ids);
        }
      });
    },
    flushQueuedProjects: function(req, res, next) {
      var options;
      if (next == null) {
        next = function(error) {};
      }
      res.setTimeout(10 * 60 * 1000);
      options = {
        limit: req.query.limit || 1000,
        timeout: 5 * 60 * 1000,
        min_delete_age: req.query.min_delete_age || 5 * 60 * 1000
      };
      return DeleteQueueManager.flushAndDeleteOldProjects(options, function(err, flushed) {
        if (err != null) {
          logger.err({
            err: err
          }, "error flushing old projects");
          return res.send(500);
        } else {
          logger.log({
            flushed: flushed
          }, "flush of queued projects completed");
          return res.send({
            flushed: flushed
          });
        }
      });
    }
  };

}).call(this);

//# sourceMappingURL=HttpController.map
