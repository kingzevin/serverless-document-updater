// Generated by CoffeeScript 1.7.1
(function() {
  var load;

  load = function() {
    var RangesTracker;
    return RangesTracker = (function() {
      function RangesTracker(changes, comments) {
        this.changes = changes != null ? changes : [];
        this.comments = comments != null ? comments : [];
        this.setIdSeed(RangesTracker.generateIdSeed());
        this.resetDirtyState();
      }

      RangesTracker.prototype.getIdSeed = function() {
        return this.id_seed;
      };

      RangesTracker.prototype.setIdSeed = function(seed) {
        this.id_seed = seed;
        return this.id_increment = 0;
      };

      RangesTracker.generateIdSeed = function() {
        var machine, pid, timestamp;
        pid = Math.floor(Math.random() * 32767.).toString(16);
        machine = Math.floor(Math.random() * 16777216.).toString(16);
        timestamp = Math.floor(new Date().valueOf() / 1000).toString(16);
        return '00000000'.substr(0, 8 - timestamp.length) + timestamp + '000000'.substr(0, 6 - machine.length) + machine + '0000'.substr(0, 4 - pid.length) + pid;
      };

      RangesTracker.generateId = function() {
        return this.generateIdSeed() + "000001";
      };

      RangesTracker.prototype.newId = function() {
        var id, increment;
        this.id_increment++;
        increment = this.id_increment.toString(16);
        id = this.id_seed + '000000'.substr(0, 6 - increment.length) + increment;
        return id;
      };

      RangesTracker.prototype.getComment = function(comment_id) {
        var c, comment, _i, _len, _ref;
        comment = null;
        _ref = this.comments;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          c = _ref[_i];
          if (c.id === comment_id) {
            comment = c;
            break;
          }
        }
        return comment;
      };

      RangesTracker.prototype.removeCommentId = function(comment_id) {
        var comment;
        comment = this.getComment(comment_id);
        if (comment == null) {
          return;
        }
        this.comments = this.comments.filter(function(c) {
          return c.id !== comment_id;
        });
        return this._markAsDirty(comment, "comment", "removed");
      };

      RangesTracker.prototype.moveCommentId = function(comment_id, position, text) {
        var comment, _i, _len, _ref, _results;
        _ref = this.comments;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          comment = _ref[_i];
          if (comment.id === comment_id) {
            comment.op.p = position;
            comment.op.c = text;
            _results.push(this._markAsDirty(comment, "comment", "moved"));
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      };

      RangesTracker.prototype.getChange = function(change_id) {
        var c, change, _i, _len, _ref;
        change = null;
        _ref = this.changes;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          c = _ref[_i];
          if (c.id === change_id) {
            change = c;
            break;
          }
        }
        return change;
      };

      RangesTracker.prototype.getChanges = function(change_ids) {
        var change, change_id, changes_response, ids_map, _i, _j, _len, _len1, _ref;
        changes_response = [];
        ids_map = {};
        for (_i = 0, _len = change_ids.length; _i < _len; _i++) {
          change_id = change_ids[_i];
          ids_map[change_id] = true;
        }
        _ref = this.changes;
        for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
          change = _ref[_j];
          if (ids_map[change.id]) {
            delete ids_map[change.id];
            changes_response.push(change);
          }
        }
        return changes_response;
      };

      RangesTracker.prototype.removeChangeId = function(change_id) {
        var change;
        change = this.getChange(change_id);
        if (change == null) {
          return;
        }
        return this._removeChange(change);
      };

      RangesTracker.prototype.removeChangeIds = function(change_to_remove_ids) {
        var change, change_id, i, remaining_changes, remove_change_id, _i, _j, _len, _len1, _ref;
        if (!(change_to_remove_ids != null ? change_to_remove_ids.length : void 0) > 0) {
          return;
        }
        i = this.changes.length;
        remove_change_id = {};
        for (_i = 0, _len = change_to_remove_ids.length; _i < _len; _i++) {
          change_id = change_to_remove_ids[_i];
          remove_change_id[change_id] = true;
        }
        remaining_changes = [];
        _ref = this.changes;
        for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
          change = _ref[_j];
          if (remove_change_id[change.id]) {
            delete remove_change_id[change.id];
            this._markAsDirty(change, "change", "removed");
          } else {
            remaining_changes.push(change);
          }
        }
        return this.changes = remaining_changes;
      };

      RangesTracker.prototype.validate = function(text) {
        var change, comment, content, _i, _j, _len, _len1, _ref, _ref1;
        _ref = this.changes;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          change = _ref[_i];
          if (change.op.i != null) {
            content = text.slice(change.op.p, change.op.p + change.op.i.length);
            if (content !== change.op.i) {
              throw new Error("Change (" + (JSON.stringify(change)) + ") doesn't match text (" + (JSON.stringify(content)) + ")");
            }
          }
        }
        _ref1 = this.comments;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          comment = _ref1[_j];
          content = text.slice(comment.op.p, comment.op.p + comment.op.c.length);
          if (content !== comment.op.c) {
            throw new Error("Comment (" + (JSON.stringify(comment)) + ") doesn't match text (" + (JSON.stringify(content)) + ")");
          }
        }
        return true;
      };

      RangesTracker.prototype.applyOp = function(op, metadata) {
        if (metadata == null) {
          metadata = {};
        }
        if (metadata.ts == null) {
          metadata.ts = new Date();
        }
        if (op.i != null) {
          this.applyInsertToChanges(op, metadata);
          return this.applyInsertToComments(op);
        } else if (op.d != null) {
          this.applyDeleteToChanges(op, metadata);
          return this.applyDeleteToComments(op);
        } else if (op.c != null) {
          return this.addComment(op, metadata);
        } else {
          throw new Error("unknown op type");
        }
      };

      RangesTracker.prototype.applyOps = function(ops, metadata) {
        var op, _i, _len, _results;
        if (metadata == null) {
          metadata = {};
        }
        _results = [];
        for (_i = 0, _len = ops.length; _i < _len; _i++) {
          op = ops[_i];
          _results.push(this.applyOp(op, metadata));
        }
        return _results;
      };

      RangesTracker.prototype.addComment = function(op, metadata) {
        var comment, existing;
        existing = this.getComment(op.t);
        if (existing != null) {
          this.moveCommentId(op.t, op.p, op.c);
          return existing;
        } else {
          this.comments.push(comment = {
            id: op.t || this.newId(),
            op: {
              c: op.c,
              p: op.p,
              t: op.t
            },
            metadata: metadata
          });
          this._markAsDirty(comment, "comment", "added");
          return comment;
        }
      };

      RangesTracker.prototype.applyInsertToComments = function(op) {
        var comment, offset, _i, _len, _ref, _results;
        _ref = this.comments;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          comment = _ref[_i];
          if (op.p <= comment.op.p) {
            comment.op.p += op.i.length;
            _results.push(this._markAsDirty(comment, "comment", "moved"));
          } else if (op.p < comment.op.p + comment.op.c.length) {
            offset = op.p - comment.op.p;
            comment.op.c = comment.op.c.slice(0, +(offset - 1) + 1 || 9e9) + op.i + comment.op.c.slice(offset);
            _results.push(this._markAsDirty(comment, "comment", "moved"));
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      };

      RangesTracker.prototype.applyDeleteToComments = function(op) {
        var comment, comment_end, comment_length, comment_start, deleted_comment, deleted_op_content, offset, op_end, op_length, op_start, remaining_after, remaining_before, _i, _len, _ref, _results;
        op_start = op.p;
        op_length = op.d.length;
        op_end = op.p + op_length;
        _ref = this.comments;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          comment = _ref[_i];
          comment_start = comment.op.p;
          comment_end = comment.op.p + comment.op.c.length;
          comment_length = comment_end - comment_start;
          if (op_end <= comment_start) {
            comment.op.p -= op_length;
            _results.push(this._markAsDirty(comment, "comment", "moved"));
          } else if (op_start >= comment_end) {

          } else {
            if (op_start <= comment_start) {
              remaining_before = "";
            } else {
              remaining_before = comment.op.c.slice(0, op_start - comment_start);
            }
            if (op_end >= comment_end) {
              remaining_after = "";
            } else {
              remaining_after = comment.op.c.slice(op_end - comment_start);
            }
            deleted_comment = comment.op.c.slice(remaining_before.length, comment_length - remaining_after.length);
            offset = Math.max(0, comment_start - op_start);
            deleted_op_content = op.d.slice(offset).slice(0, deleted_comment.length);
            if (deleted_comment !== deleted_op_content) {
              throw new Error("deleted content does not match comment content");
            }
            comment.op.p = Math.min(comment_start, op_start);
            comment.op.c = remaining_before + remaining_after;
            _results.push(this._markAsDirty(comment, "comment", "moved"));
          }
        }
        return _results;
      };

      RangesTracker.prototype.applyInsertToChanges = function(op, metadata) {
        var after_change, after_content, already_merged, before_content, change, change_end, change_start, i, is_change_overlapping, is_insert_blocked_by_delete, is_op_adjacent_to_next_delete, is_same_user, key, moved_changes, new_changes, next_change, offset, op_end, op_length, op_start, previous_change, remove_changes, undoing, value, will_op_cancel_next_delete, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _results;
        op_start = op.p;
        op_length = op.i.length;
        op_end = op.p + op_length;
        undoing = !!op.u;
        already_merged = false;
        previous_change = null;
        moved_changes = [];
        remove_changes = [];
        new_changes = [];
        _ref = this.changes;
        for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
          change = _ref[i];
          change_start = change.op.p;
          if (change.op.d != null) {
            if (op_start < change_start) {
              change.op.p += op_length;
              moved_changes.push(change);
            } else if (op_start === change_start) {
              if (undoing && change.op.d.length >= op.i.length && change.op.d.slice(0, op.i.length) === op.i) {
                change.op.d = change.op.d.slice(op.i.length);
                change.op.p += op.i.length;
                if (change.op.d === "") {
                  remove_changes.push(change);
                } else {
                  moved_changes.push(change);
                }
                already_merged = true;
              } else {
                change.op.p += op_length;
                moved_changes.push(change);
              }
            }
          } else if (change.op.i != null) {
            change_end = change_start + change.op.i.length;
            is_change_overlapping = op_start >= change_start && op_start <= change_end;
            is_same_user = metadata.user_id === change.metadata.user_id;
            next_change = this.changes[i + 1];
            is_op_adjacent_to_next_delete = (next_change != null) && (next_change.op.d != null) && op.p === change_end && next_change.op.p === op.p;
            will_op_cancel_next_delete = undoing && is_op_adjacent_to_next_delete && next_change.op.d.slice(0, op.i.length) === op.i;
            is_insert_blocked_by_delete = (previous_change != null) && (previous_change.op.d != null) && previous_change.op.p === op_end;
            if (this.track_changes && is_change_overlapping && !is_insert_blocked_by_delete && !already_merged && !will_op_cancel_next_delete && is_same_user) {
              offset = op_start - change_start;
              change.op.i = change.op.i.slice(0, offset) + op.i + change.op.i.slice(offset);
              change.metadata.ts = metadata.ts;
              already_merged = true;
              moved_changes.push(change);
            } else if (op_start <= change_start) {
              change.op.p += op_length;
              moved_changes.push(change);
            } else if ((!is_same_user || !this.track_changes) && (change_start < op_start && op_start < change_end)) {
              offset = op_start - change_start;
              before_content = change.op.i.slice(0, offset);
              after_content = change.op.i.slice(offset);
              change.op.i = before_content;
              moved_changes.push(change);
              after_change = {
                op: {
                  i: after_content,
                  p: change_start + offset + op_length
                },
                metadata: {}
              };
              _ref1 = change.metadata;
              for (key in _ref1) {
                value = _ref1[key];
                after_change.metadata[key] = value;
              }
              new_changes.push(after_change);
            }
          }
          previous_change = change;
        }
        if (this.track_changes && !already_merged) {
          this._addOp(op, metadata);
        }
        for (_j = 0, _len1 = new_changes.length; _j < _len1; _j++) {
          _ref2 = new_changes[_j], op = _ref2.op, metadata = _ref2.metadata;
          this._addOp(op, metadata);
        }
        for (_k = 0, _len2 = remove_changes.length; _k < _len2; _k++) {
          change = remove_changes[_k];
          this._removeChange(change);
        }
        _results = [];
        for (_l = 0, _len3 = moved_changes.length; _l < _len3; _l++) {
          change = moved_changes[_l];
          _results.push(this._markAsDirty(change, "change", "moved"));
        }
        return _results;
      };

      RangesTracker.prototype.applyDeleteToChanges = function(op, metadata) {
        var change, change_end, change_start, delete_remaining_after, delete_remaining_before, delete_removed_length, delete_removed_start, insert_remaining, insert_remaining_after, insert_remaining_before, modification, moved_changes, offset, op_end, op_length, op_modifications, op_start, remove_changes, results, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _results;
        op_start = op.p;
        op_length = op.d.length;
        op_end = op.p + op_length;
        remove_changes = [];
        moved_changes = [];
        op_modifications = [];
        _ref = this.changes;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          change = _ref[_i];
          if (change.op.i != null) {
            change_start = change.op.p;
            change_end = change_start + change.op.i.length;
            if (op_end <= change_start) {
              change.op.p -= op_length;
              moved_changes.push(change);
            } else if (op_start >= change_end) {

            } else {
              if (op_start >= change_start) {
                delete_remaining_before = "";
                insert_remaining_before = change.op.i.slice(0, op_start - change_start);
              } else {
                delete_remaining_before = op.d.slice(0, change_start - op_start);
                insert_remaining_before = "";
              }
              if (op_end <= change_end) {
                delete_remaining_after = "";
                insert_remaining_after = change.op.i.slice(op_end - change_start);
              } else {
                delete_remaining_after = op.d.slice(change_end - op_start);
                insert_remaining_after = "";
              }
              insert_remaining = insert_remaining_before + insert_remaining_after;
              if (insert_remaining.length > 0) {
                change.op.i = insert_remaining;
                change.op.p = Math.min(change_start, op_start);
                change.metadata.ts = metadata.ts;
                moved_changes.push(change);
              } else {
                remove_changes.push(change);
              }
              delete_removed_length = op.d.length - delete_remaining_before.length - delete_remaining_after.length;
              delete_removed_start = delete_remaining_before.length;
              modification = {
                d: op.d.slice(delete_removed_start, delete_removed_start + delete_removed_length),
                p: delete_removed_start
              };
              if (modification.d.length > 0) {
                op_modifications.push(modification);
              }
            }
          } else if (change.op.d != null) {
            change_start = change.op.p;
            if (op_end < change_start || (!this.track_changes && op_end === change_start)) {
              change.op.p -= op_length;
              moved_changes.push(change);
            } else if ((op_start <= change_start && change_start <= op_end)) {
              if (this.track_changes) {
                offset = change_start - op_start;
                op_modifications.push({
                  i: change.op.d,
                  p: offset
                });
                remove_changes.push(change);
              } else {
                change.op.p = op_start;
                moved_changes.push(change);
              }
            }
          }
        }
        op = {
          p: op.p,
          d: this._applyOpModifications(op.d, op_modifications)
        };
        for (_j = 0, _len1 = remove_changes.length; _j < _len1; _j++) {
          change = remove_changes[_j];
          if (op.d.length > 0 && (change.op.d != null) && (op.p <= (_ref1 = change.op.p) && _ref1 <= op.p + op.d.length)) {
            change.op.p = op.p;
            change.op.d = op.d;
            change.metadata = metadata;
            moved_changes.push(change);
            op.d = "";
          } else {
            this._removeChange(change);
          }
        }
        if (this.track_changes && op.d.length > 0) {
          this._addOp(op, metadata);
        } else {
          results = this._scanAndMergeAdjacentUpdates();
          moved_changes = moved_changes.concat(results.moved_changes);
          _ref2 = results.remove_changes;
          for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
            change = _ref2[_k];
            this._removeChange(change);
            moved_changes = moved_changes.filter(function(c) {
              return c !== change;
            });
          }
        }
        _results = [];
        for (_l = 0, _len3 = moved_changes.length; _l < _len3; _l++) {
          change = moved_changes[_l];
          _results.push(this._markAsDirty(change, "change", "moved"));
        }
        return _results;
      };

      RangesTracker.prototype._addOp = function(op, metadata) {
        var change;
        change = {
          id: this.newId(),
          op: this._clone(op),
          metadata: this._clone(metadata)
        };
        this.changes.push(change);
        this.changes.sort(function(c1, c2) {
          var result;
          result = c1.op.p - c2.op.p;
          if (result !== 0) {
            return result;
          } else if ((c1.op.i != null) && (c2.op.d != null)) {
            return 1;
          } else {
            return -1;
          }
        });
        return this._markAsDirty(change, "change", "added");
      };

      RangesTracker.prototype._removeChange = function(change) {
        this.changes = this.changes.filter(function(c) {
          return c.id !== change.id;
        });
        return this._markAsDirty(change, "change", "removed");
      };

      RangesTracker.prototype._applyOpModifications = function(content, op_modifications) {
        var modification, _i, _len;
        op_modifications.sort(function(a, b) {
          var result;
          result = b.p - a.p;
          if (result !== 0) {
            return result;
          } else if ((a.i != null) && (b.d != null)) {
            return 1;
          } else {
            return -1;
          }
        });
        for (_i = 0, _len = op_modifications.length; _i < _len; _i++) {
          modification = op_modifications[_i];
          if (modification.i != null) {
            content = content.slice(0, modification.p) + modification.i + content.slice(modification.p);
          } else if (modification.d != null) {
            if (content.slice(modification.p, modification.p + modification.d.length) !== modification.d) {
              throw new Error("deleted content does not match. content: " + (JSON.stringify(content)) + "; modification: " + (JSON.stringify(modification)));
            }
            content = content.slice(0, modification.p) + content.slice(modification.p + modification.d.length);
          }
        }
        return content;
      };

      RangesTracker.prototype._scanAndMergeAdjacentUpdates = function() {
        var change, change_start, change_user_id, moved_changes, previous_change, previous_change_end, previous_change_user_id, remove_changes, _i, _len, _ref;
        previous_change = null;
        remove_changes = [];
        moved_changes = [];
        _ref = this.changes;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          change = _ref[_i];
          if (((previous_change != null ? previous_change.op.i : void 0) != null) && (change.op.i != null)) {
            previous_change_end = previous_change.op.p + previous_change.op.i.length;
            previous_change_user_id = previous_change.metadata.user_id;
            change_start = change.op.p;
            change_user_id = change.metadata.user_id;
            if (previous_change_end === change_start && previous_change_user_id === change_user_id) {
              remove_changes.push(change);
              previous_change.op.i += change.op.i;
              moved_changes.push(previous_change);
            }
          } else if (((previous_change != null ? previous_change.op.d : void 0) != null) && (change.op.d != null) && previous_change.op.p === change.op.p) {
            previous_change.op.d += change.op.d;
            remove_changes.push(change);
            moved_changes.push(previous_change);
          } else {
            previous_change = change;
          }
        }
        return {
          moved_changes: moved_changes,
          remove_changes: remove_changes
        };
      };

      RangesTracker.prototype.resetDirtyState = function() {
        return this._dirtyState = {
          comment: {
            moved: {},
            removed: {},
            added: {}
          },
          change: {
            moved: {},
            removed: {},
            added: {}
          }
        };
      };

      RangesTracker.prototype.getDirtyState = function() {
        return this._dirtyState;
      };

      RangesTracker.prototype._markAsDirty = function(object, type, action) {
        return this._dirtyState[type][action][object.id] = object;
      };

      RangesTracker.prototype._clone = function(object) {
        var clone, k, v;
        clone = {};
        for (k in object) {
          v = object[k];
          clone[k] = v;
        }
        return clone;
      };

      return RangesTracker;

    })();
  };

  if (typeof define !== "undefined" && define !== null) {
    define([], load);
  } else {
    module.exports = load();
  }

}).call(this);

//# sourceMappingURL=RangesTracker.map
