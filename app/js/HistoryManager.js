// Generated by CoffeeScript 1.7.1
(function() {
  var HistoryManager, HistoryRedisManager, ProjectHistoryRedisManager, RedisManager, Settings, async, logger, metrics, request;

  async = require("async");

  logger = require("logger-sharelatex");

  request = require("request");

  Settings = require("settings-sharelatex");

  HistoryRedisManager = require("./HistoryRedisManager");

  ProjectHistoryRedisManager = require("./ProjectHistoryRedisManager");

  RedisManager = require("./RedisManager");

  metrics = require("./Metrics");

  module.exports = HistoryManager = {
    flushDocChangesAsync: function(project_id, doc_id) {
      var _ref;
      if (((_ref = Settings.apis) != null ? _ref.trackchanges : void 0) == null) {
        logger.warn({
          doc_id: doc_id
        }, "track changes API is not configured, so not flushing");
        return;
      }
      return RedisManager.getHistoryType(doc_id, function(err, projectHistoryType) {
        var url;
        if (err != null) {
          logger.warn({
            err: err,
            doc_id: doc_id
          }, "error getting history type");
        }
        if (Settings.disableDoubleFlush && projectHistoryType === "project-history") {
          return logger.debug({
            doc_id: doc_id,
            projectHistoryType: projectHistoryType
          }, "skipping track-changes flush");
        } else {
          metrics.inc('history-flush', 1, {
            status: 'track-changes'
          });
          url = "" + Settings.apis.trackchanges.url + "/project/" + project_id + "/doc/" + doc_id + "/flush";
          logger.log({
            project_id: project_id,
            doc_id: doc_id,
            url: url,
            projectHistoryType: projectHistoryType
          }, "flushing doc in track changes api");
          return request.post(url, function(error, res, body) {
            if (error != null) {
              return logger.error({
                error: error,
                doc_id: doc_id,
                project_id: project_id
              }, "track changes doc to track changes api");
            } else if (res.statusCode < 200 && res.statusCode >= 300) {
              return logger.error({
                doc_id: doc_id,
                project_id: project_id
              }, "track changes api returned a failure status code: " + res.statusCode);
            }
          });
        }
      });
    },
    flushProjectChangesAsync: function(project_id) {
      var _ref, _ref1;
      if (!((_ref = Settings.apis) != null ? (_ref1 = _ref.project_history) != null ? _ref1.enabled : void 0 : void 0)) {
        return;
      }
      return HistoryManager.flushProjectChanges(project_id, {
        background: true
      }, function() {});
    },
    flushProjectChanges: function(project_id, options, callback) {
      var qs, url, _ref, _ref1;
      if (callback == null) {
        callback = function(error) {};
      }
      if (!((_ref = Settings.apis) != null ? (_ref1 = _ref.project_history) != null ? _ref1.enabled : void 0 : void 0)) {
        return callback();
      }
      if (options.skip_history_flush) {
        logger.log({
          project_id: project_id
        }, "skipping flush of project history");
        return callback();
      }
      metrics.inc('history-flush', 1, {
        status: 'project-history'
      });
      url = "" + Settings.apis.project_history.url + "/project/" + project_id + "/flush";
      qs = {};
      if (options.background) {
        qs.background = true;
      }
      logger.log({
        project_id: project_id,
        url: url,
        qs: qs
      }, "flushing doc in project history api");
      return request.post({
        url: url,
        qs: qs
      }, function(error, res, body) {
        if (error != null) {
          logger.error({
            error: error,
            project_id: project_id
          }, "project history doc to track changes api");
          return callback(error);
        } else if (res.statusCode < 200 && res.statusCode >= 300) {
          logger.error({
            project_id: project_id
          }, "project history api returned a failure status code: " + res.statusCode);
          return callback(error);
        } else {
          return callback();
        }
      });
    },
    FLUSH_DOC_EVERY_N_OPS: 100,
    FLUSH_PROJECT_EVERY_N_OPS: 500,
    recordAndFlushHistoryOps: function(project_id, doc_id, ops, doc_ops_length, project_ops_length, callback) {
      var _ref, _ref1;
      if (ops == null) {
        ops = [];
      }
      if (callback == null) {
        callback = function(error) {};
      }
      if (ops.length === 0) {
        return callback();
      }
      if ((_ref = Settings.apis) != null ? (_ref1 = _ref.project_history) != null ? _ref1.enabled : void 0 : void 0) {
        if (HistoryManager.shouldFlushHistoryOps(project_ops_length, ops.length, HistoryManager.FLUSH_PROJECT_EVERY_N_OPS)) {
          logger.log({
            project_ops_length: project_ops_length,
            project_id: project_id
          }, "flushing project history api");
          HistoryManager.flushProjectChangesAsync(project_id);
        }
      }
      if (typeof doc_ops_length === 'undefined') {
        logger.debug({
          project_id: project_id,
          doc_id: doc_id
        }, "skipping flush to track-changes, only using project-history");
        return callback();
      }
      return HistoryRedisManager.recordDocHasHistoryOps(project_id, doc_id, ops, function(error) {
        if (error != null) {
          return callback(error);
        }
        if (HistoryManager.shouldFlushHistoryOps(doc_ops_length, ops.length, HistoryManager.FLUSH_DOC_EVERY_N_OPS)) {
          logger.log({
            doc_ops_length: doc_ops_length,
            doc_id: doc_id,
            project_id: project_id
          }, "flushing track changes api");
          HistoryManager.flushDocChangesAsync(project_id, doc_id);
        }
        return callback();
      });
    },
    shouldFlushHistoryOps: function(length, ops_length, threshold) {
      var newBlock, prevBlock, previousLength;
      if (!length) {
        return false;
      }
      previousLength = length - ops_length;
      prevBlock = Math.floor(previousLength / threshold);
      newBlock = Math.floor(length / threshold);
      return newBlock !== prevBlock;
    },
    MAX_PARALLEL_REQUESTS: 4,
    resyncProjectHistory: function(project_id, projectHistoryId, docs, files, callback) {
      return ProjectHistoryRedisManager.queueResyncProjectStructure(project_id, projectHistoryId, docs, files, function(error) {
        var DocumentManager, resyncDoc;
        if (error != null) {
          return callback(error);
        }
        DocumentManager = require("./DocumentManager");
        resyncDoc = function(doc, cb) {
          return DocumentManager.resyncDocContentsWithLock(project_id, doc.doc, cb);
        };
        return async.eachLimit(docs, HistoryManager.MAX_PARALLEL_REQUESTS, resyncDoc, callback);
      });
    }
  };

}).call(this);

//# sourceMappingURL=HistoryManager.map
