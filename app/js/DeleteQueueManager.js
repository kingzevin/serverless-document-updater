// Generated by CoffeeScript 1.7.1
(function() {
  var DeleteQueueManager, ProjectManager, RedisManager, Settings, async, logger, metrics;

  Settings = require('settings-sharelatex');

  RedisManager = require("./RedisManager");

  ProjectManager = require("./ProjectManager");

  logger = require("logger-sharelatex");

  metrics = require("./Metrics");

  async = require("async");

  module.exports = DeleteQueueManager = {
    flushAndDeleteOldProjects: function(options, callback) {
      var count, cutoffTime, flushNextProject, flushProjectIfNotModified, startTime;
      startTime = Date.now();
      cutoffTime = startTime - options.min_delete_age + 100 * (Math.random() - 0.5);
      count = 0;
      flushProjectIfNotModified = function(project_id, flushTimestamp, cb) {
        return ProjectManager.getProjectDocsTimestamps(project_id, function(err, timestamps) {
          var timestamp, _i, _len;
          if (err != null) {
            return callback(err);
          }
          if (timestamps.length === 0) {
            logger.log({
              project_id: project_id
            }, "skipping flush of queued project - no timestamps");
            return cb();
          }
          for (_i = 0, _len = timestamps.length; _i < _len; _i++) {
            timestamp = timestamps[_i];
            if (!(timestamp > flushTimestamp)) {
              continue;
            }
            metrics.inc("queued-delete-skipped");
            logger.debug({
              project_id: project_id,
              timestamps: timestamps,
              flushTimestamp: flushTimestamp
            }, "found newer timestamp, will skip delete");
            return cb();
          }
          logger.log({
            project_id: project_id,
            flushTimestamp: flushTimestamp
          }, "flushing queued project");
          return ProjectManager.flushAndDeleteProjectWithLocks(project_id, {
            skip_history_flush: false
          }, function(err) {
            if (err != null) {
              logger.err({
                project_id: project_id,
                err: err
              }, "error flushing queued project");
            }
            metrics.inc("queued-delete-completed");
            return cb(null, true);
          });
        });
      };
      flushNextProject = function() {
        var now;
        now = Date.now();
        if (now - startTime > options.timeout) {
          logger.log("hit time limit on flushing old projects");
          return callback(null, count);
        }
        if (count > options.limit) {
          logger.log("hit count limit on flushing old projects");
          return callback(null, count);
        }
        return RedisManager.getNextProjectToFlushAndDelete(cutoffTime, function(err, project_id, flushTimestamp, queueLength) {
          if (err != null) {
            return callback(err);
          }
          if (project_id == null) {
            return callback(null, count);
          }
          logger.log({
            project_id: project_id,
            queueLength: queueLength
          }, "flushing queued project");
          metrics.globalGauge("queued-flush-backlog", queueLength);
          return flushProjectIfNotModified(project_id, flushTimestamp, function(err, flushed) {
            if (flushed) {
              count++;
            }
            return flushNextProject();
          });
        });
      };
      return flushNextProject();
    },
    startBackgroundFlush: function() {
      var LONG_DELAY, SHORT_DELAY, doFlush;
      SHORT_DELAY = 10;
      LONG_DELAY = 1000;
      doFlush = function() {
        if (Settings.shuttingDown) {
          logger.warn("discontinuing background flush due to shutdown");
          return;
        }
        return DeleteQueueManager.flushAndDeleteOldProjects({
          timeout: 1000,
          min_delete_age: 3 * 60 * 1000,
          limit: 1000
        }, function(err, flushed) {
          return setTimeout(doFlush, (flushed > 10 ? SHORT_DELAY : LONG_DELAY));
        });
      };
      return doFlush();
    }
  };

}).call(this);

//# sourceMappingURL=DeleteQueueManager.map
