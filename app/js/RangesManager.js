// Generated by CoffeeScript 1.7.1
(function() {
  var RangesManager, RangesTracker, logger, _;

  RangesTracker = require("./RangesTracker");

  logger = require("logger-sharelatex");

  _ = require("lodash");

  module.exports = RangesManager = {
    MAX_COMMENTS: 500,
    MAX_CHANGES: 2000,
    applyUpdate: function(project_id, doc_id, entries, updates, newDocLines, callback) {
      var changes, comments, emptyRangeCountAfter, emptyRangeCountBefore, error, op, rangesTracker, rangesWereCollapsed, response, update, _i, _j, _len, _len1, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;
      if (entries == null) {
        entries = {};
      }
      if (updates == null) {
        updates = [];
      }
      if (callback == null) {
        callback = function(error, new_entries, ranges_were_collapsed) {};
      }
      _ref = _.cloneDeep(entries), changes = _ref.changes, comments = _ref.comments;
      rangesTracker = new RangesTracker(changes, comments);
      emptyRangeCountBefore = RangesManager._emptyRangesCount(rangesTracker);
      for (_i = 0, _len = updates.length; _i < _len; _i++) {
        update = updates[_i];
        rangesTracker.track_changes = !!update.meta.tc;
        if (!!update.meta.tc) {
          rangesTracker.setIdSeed(update.meta.tc);
        }
        _ref1 = update.op;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          op = _ref1[_j];
          try {
            rangesTracker.applyOp(op, {
              user_id: (_ref2 = update.meta) != null ? _ref2.user_id : void 0
            });
          } catch (_error) {
            error = _error;
            return callback(error);
          }
        }
      }
      if (((_ref3 = rangesTracker.changes) != null ? _ref3.length : void 0) > RangesManager.MAX_CHANGES || ((_ref4 = rangesTracker.comments) != null ? _ref4.length : void 0) > RangesManager.MAX_COMMENTS) {
        return callback(new Error("too many comments or tracked changes"));
      }
      try {
        rangesTracker.validate(newDocLines.join("\n"));
      } catch (_error) {
        error = _error;
        logger.error({
          err: error,
          project_id: project_id,
          doc_id: doc_id,
          newDocLines: newDocLines,
          updates: updates
        }, "error validating ranges");
        return callback(error);
      }
      emptyRangeCountAfter = RangesManager._emptyRangesCount(rangesTracker);
      rangesWereCollapsed = emptyRangeCountAfter > emptyRangeCountBefore;
      response = RangesManager._getRanges(rangesTracker);
      logger.log({
        project_id: project_id,
        doc_id: doc_id,
        changesCount: (_ref5 = response.changes) != null ? _ref5.length : void 0,
        commentsCount: (_ref6 = response.comments) != null ? _ref6.length : void 0,
        rangesWereCollapsed: rangesWereCollapsed
      }, "applied updates to ranges");
      return callback(null, response, rangesWereCollapsed);
    },
    acceptChanges: function(change_ids, ranges, callback) {
      var changes, comments, rangesTracker, response;
      if (callback == null) {
        callback = function(error, ranges) {};
      }
      changes = ranges.changes, comments = ranges.comments;
      logger.log("accepting " + change_ids.length + " changes in ranges");
      rangesTracker = new RangesTracker(changes, comments);
      rangesTracker.removeChangeIds(change_ids);
      response = RangesManager._getRanges(rangesTracker);
      return callback(null, response);
    },
    deleteComment: function(comment_id, ranges, callback) {
      var changes, comments, rangesTracker, response;
      if (callback == null) {
        callback = function(error, ranges) {};
      }
      changes = ranges.changes, comments = ranges.comments;
      logger.log({
        comment_id: comment_id
      }, "deleting comment in ranges");
      rangesTracker = new RangesTracker(changes, comments);
      rangesTracker.removeCommentId(comment_id);
      response = RangesManager._getRanges(rangesTracker);
      return callback(null, response);
    },
    _getRanges: function(rangesTracker) {
      var response, _ref, _ref1;
      response = {};
      if (((_ref = rangesTracker.changes) != null ? _ref.length : void 0) > 0) {
        if (response == null) {
          response = {};
        }
        response.changes = rangesTracker.changes;
      }
      if (((_ref1 = rangesTracker.comments) != null ? _ref1.length : void 0) > 0) {
        if (response == null) {
          response = {};
        }
        response.comments = rangesTracker.comments;
      }
      return response;
    },
    _emptyRangesCount: function(ranges) {
      var change, comment, count, _i, _j, _len, _len1, _ref, _ref1;
      count = 0;
      _ref = ranges.comments || [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        comment = _ref[_i];
        if (comment.op.c === "") {
          count++;
        }
      }
      _ref1 = ranges.changes || [];
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        change = _ref1[_j];
        if (change.op.i != null) {
          if (change.op.i === "") {
            count++;
          }
        }
      }
      return count;
    }
  };

}).call(this);

//# sourceMappingURL=RangesManager.map
