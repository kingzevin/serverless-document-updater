// Generated by CoffeeScript 1.7.1
(function() {
  var ProjectHistoryRedisManager, Settings, logger, projectHistoryKeys, rclient, _ref, _ref1,
    __slice = [].slice;

  Settings = require('settings-sharelatex');

  projectHistoryKeys = (_ref = Settings.redis) != null ? (_ref1 = _ref.project_history) != null ? _ref1.key_schema : void 0 : void 0;

  rclient = require("redis-sharelatex").createClient(Settings.redis.documentupdater);

  logger = require('logger-sharelatex');

  module.exports = ProjectHistoryRedisManager = {
    queueOps: function() {
      var callback, multi, ops, project_id, _i;
      project_id = arguments[0], ops = 3 <= arguments.length ? __slice.call(arguments, 1, _i = arguments.length - 1) : (_i = 1, []), callback = arguments[_i++];
      if (callback == null) {
        callback = function(error, projectUpdateCount) {};
      }
      multi = rclient.multi();
      multi.rpush.apply(multi, [projectHistoryKeys.projectHistoryOps({
        project_id: project_id
      })].concat(__slice.call(ops)));
      multi.setnx(projectHistoryKeys.projectHistoryFirstOpTimestamp({
        project_id: project_id
      }), Date.now());
      return multi.exec(function(error, result) {
        if (error != null) {
          return callback(error);
        }
        return callback(null, result[0]);
      });
    },
    queueRenameEntity: function(project_id, projectHistoryId, entity_type, entity_id, user_id, projectUpdate, callback) {
      var jsonUpdate;
      projectUpdate = {
        pathname: projectUpdate.pathname,
        new_pathname: projectUpdate.newPathname,
        meta: {
          user_id: user_id,
          ts: new Date()
        },
        version: projectUpdate.version,
        projectHistoryId: projectHistoryId
      };
      projectUpdate[entity_type] = entity_id;
      logger.log({
        project_id: project_id,
        projectUpdate: projectUpdate
      }, "queue rename operation to project-history");
      jsonUpdate = JSON.stringify(projectUpdate);
      return ProjectHistoryRedisManager.queueOps(project_id, jsonUpdate, callback);
    },
    queueAddEntity: function(project_id, projectHistoryId, entity_type, entitiy_id, user_id, projectUpdate, callback) {
      var jsonUpdate;
      if (callback == null) {
        callback = function(error) {};
      }
      projectUpdate = {
        pathname: projectUpdate.pathname,
        docLines: projectUpdate.docLines,
        url: projectUpdate.url,
        meta: {
          user_id: user_id,
          ts: new Date()
        },
        version: projectUpdate.version,
        projectHistoryId: projectHistoryId
      };
      projectUpdate[entity_type] = entitiy_id;
      logger.log({
        project_id: project_id,
        projectUpdate: projectUpdate
      }, "queue add operation to project-history");
      jsonUpdate = JSON.stringify(projectUpdate);
      return ProjectHistoryRedisManager.queueOps(project_id, jsonUpdate, callback);
    },
    queueResyncProjectStructure: function(project_id, projectHistoryId, docs, files, callback) {
      var jsonUpdate, projectUpdate;
      logger.log({
        project_id: project_id,
        docs: docs,
        files: files
      }, "queue project structure resync");
      projectUpdate = {
        resyncProjectStructure: {
          docs: docs,
          files: files
        },
        projectHistoryId: projectHistoryId,
        meta: {
          ts: new Date()
        }
      };
      jsonUpdate = JSON.stringify(projectUpdate);
      return ProjectHistoryRedisManager.queueOps(project_id, jsonUpdate, callback);
    },
    queueResyncDocContent: function(project_id, projectHistoryId, doc_id, lines, version, pathname, callback) {
      var jsonUpdate, projectUpdate;
      logger.log({
        project_id: project_id,
        doc_id: doc_id,
        lines: lines,
        version: version,
        pathname: pathname
      }, "queue doc content resync");
      projectUpdate = {
        resyncDocContent: {
          content: lines.join("\n"),
          version: version
        },
        projectHistoryId: projectHistoryId,
        path: pathname,
        doc: doc_id,
        meta: {
          ts: new Date()
        }
      };
      jsonUpdate = JSON.stringify(projectUpdate);
      return ProjectHistoryRedisManager.queueOps(project_id, jsonUpdate, callback);
    }
  };

}).call(this);

//# sourceMappingURL=ProjectHistoryRedisManager.map
