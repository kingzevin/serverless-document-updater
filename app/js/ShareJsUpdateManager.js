// Generated by CoffeeScript 1.7.1
(function() {
  var Errors, EventEmitter, Keys, MAX_AGE_OF_OP, RealTimeRedisManager, Settings, ShareJsDB, ShareJsModel, ShareJsUpdateManager, crypto, logger, metrics, util;

  ShareJsModel = require("./sharejs/server/model");

  ShareJsDB = require("./ShareJsDB");

  logger = require("logger-sharelatex");

  Settings = require('settings-sharelatex');

  Keys = require("./UpdateKeys");

  EventEmitter = require("events").EventEmitter;

  util = require("util");

  RealTimeRedisManager = require("./RealTimeRedisManager");

  crypto = require("crypto");

  metrics = require('./Metrics');

  Errors = require("./Errors");

  ShareJsModel.prototype = {};

  util.inherits(ShareJsModel, EventEmitter);

  MAX_AGE_OF_OP = 80;

  module.exports = ShareJsUpdateManager = {
    getNewShareJsModel: function(project_id, doc_id, lines, version) {
      var db, model;
      db = new ShareJsDB(project_id, doc_id, lines, version);
      model = new ShareJsModel(db, {
        maxDocLength: Settings.max_doc_length,
        maximumAge: MAX_AGE_OF_OP
      });
      model.db = db;
      return model;
    },
    applyUpdate: function(project_id, doc_id, update, lines, version, callback) {
      var doc_key, incomingUpdateVersion, jobs, model;
      if (callback == null) {
        callback = function(error, updatedDocLines) {};
      }
      logger.log({
        project_id: project_id,
        doc_id: doc_id,
        update: update
      }, "applying sharejs updates");
      jobs = [];
      incomingUpdateVersion = update.v;
      model = this.getNewShareJsModel(project_id, doc_id, lines, version);
      this._listenForOps(model);
      doc_key = Keys.combineProjectIdAndDocId(project_id, doc_id);
      return model.applyOp(doc_key, update, function(error) {
        if (error != null) {
          if (error === "Op already submitted") {
            metrics.inc("sharejs.already-submitted");
            logger.warn({
              project_id: project_id,
              doc_id: doc_id,
              update: update
            }, "op has already been submitted");
            update.dup = true;
            ShareJsUpdateManager._sendOp(project_id, doc_id, update);
          } else if (/^Delete component/.test(error)) {
            metrics.inc("sharejs.delete-mismatch");
            logger.warn({
              project_id: project_id,
              doc_id: doc_id,
              update: update,
              shareJsErr: error
            }, "sharejs delete does not match");
            error = new Errors.DeleteMismatchError("Delete component does not match");
            return callback(error);
          } else {
            metrics.inc("sharejs.other-error");
            return callback(error);
          }
        }
        logger.log({
          project_id: project_id,
          doc_id: doc_id,
          error: error
        }, "applied update");
        return model.getSnapshot(doc_key, (function(_this) {
          return function(error, data) {
            var docLines, ourHash;
            if (error != null) {
              return callback(error);
            }
            if ((update.hash != null) && incomingUpdateVersion === version) {
              ourHash = ShareJsUpdateManager._computeHash(data.snapshot);
              if (ourHash !== update.hash) {
                metrics.inc("sharejs.hash-fail");
                return callback(new Error("Invalid hash"));
              } else {
                metrics.inc("sharejs.hash-pass", 0.001);
              }
            }
            docLines = data.snapshot.split(/\r\n|\n|\r/);
            return callback(null, docLines, data.v, model.db.appliedOps[doc_key] || []);
          };
        })(this));
      });
    },
    _listenForOps: function(model) {
      return model.on("applyOp", function(doc_key, opData) {
        var doc_id, project_id, _ref;
        _ref = Keys.splitProjectIdAndDocId(doc_key), project_id = _ref[0], doc_id = _ref[1];
        return ShareJsUpdateManager._sendOp(project_id, doc_id, opData);
      });
    },
    _sendOp: function(project_id, doc_id, op) {
      return RealTimeRedisManager.sendData({
        project_id: project_id,
        doc_id: doc_id,
        op: op
      });
    },
    _computeHash: function(content) {
      return crypto.createHash('sha1').update("blob " + content.length + "\x00").update(content, 'utf8').digest('hex');
    }
  };

}).call(this);

//# sourceMappingURL=ShareJsUpdateManager.map
