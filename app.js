// Generated by CoffeeScript 1.7.1
(function() {
  var DeleteQueueManager, DispatchManager, Errors, HttpController, Metrics, Path, RedisManager, Settings, app, async, docUpdaterRedisClient, eventName, events, express, host, http, logger, mongojs, port, pubsubClient, shutdownCleanly, signal, watchForEvent, _i, _j, _len, _len1, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;

  const TDMap = require('./app/js/TDMap'); // zevin: for timestamps
  const os = require('os');
  const hostname = os.hostname();

  Metrics = require("metrics-sharelatex");

  Metrics.initialize("doc-updater");

  express = require('express');

  http = require("http");

  Settings = require('settings-sharelatex');

  logger = require('logger-sharelatex');

  logger.initialize("document-updater");

  logger.logger.addSerializers(require("./app/js/LoggerSerializers"));

  if (((_ref = Settings.sentry) != null ? _ref.dsn : void 0) != null) {
    logger.initializeErrorReporting(Settings.sentry.dsn);
  }

  RedisManager = require('./app/js/RedisManager');

  DispatchManager = require('./app/js/DispatchManager');

  DeleteQueueManager = require('./app/js/DeleteQueueManager');

  Errors = require("./app/js/Errors");

  HttpController = require("./app/js/HttpController");

  mongojs = require("./app/js/mongojs");

  async = require("async");

  Path = require("path");

  Metrics.mongodb.monitor(Path.resolve(__dirname + "/node_modules/mongojs/node_modules/mongodb"), logger);

  Metrics.event_loop.monitor(logger, 100);

  app = express();

  app.configure(function() {
    app.use(Metrics.http.monitor(logger));
    app.use(express.bodyParser({
      limit: Settings.max_doc_length + 64 * 1024
    }));
    return app.use(app.router);
  });

  Metrics.injectMetricsRoute(app);

  // DispatchManager.createAndStartDispatchers(Settings.dispatcherCount || 10);

  app.param('project_id', function(req, res, next, project_id) {
    if (project_id != null ? project_id.match(/^[0-9a-f]{24}$/) : void 0) {
      return next();
    } else {
      return next(new Error("invalid project id"));
    }
  });

  app.param('doc_id', function(req, res, next, doc_id) {
    if (doc_id != null ? doc_id.match(/^[0-9a-f]{24}$/) : void 0) {
      return next();
    } else {
      return next(new Error("invalid doc id"));
    }
  });

  app.get('/project/:project_id/doc/:doc_id', HttpController.getDoc);

  app.get('/project/:project_id/doc', HttpController.getProjectDocsAndFlushIfOld);

  app.post('/project/:project_id/get_and_flush_if_old', HttpController.getProjectDocsAndFlushIfOld);

  app.post('/project/:project_id/clearState', HttpController.clearProjectState);

  app.post('/project/:project_id/doc/:doc_id', HttpController.setDoc);

  app.post('/project/:project_id/doc/:doc_id/flush', HttpController.flushDocIfLoaded);

  app["delete"]('/project/:project_id/doc/:doc_id', HttpController.flushAndDeleteDoc);

  app["delete"]('/project/:project_id', HttpController.deleteProject);

  app["delete"]('/project', HttpController.deleteMultipleProjects);

  app.post('/project/:project_id', HttpController.updateProject);

  app.post('/project/:project_id/history/resync', HttpController.resyncProjectHistory);

  app.post('/project/:project_id/flush', HttpController.flushProject);

  app.post('/project/:project_id/doc/:doc_id/change/:change_id/accept', HttpController.acceptChanges);

  app.post('/project/:project_id/doc/:doc_id/change/accept', HttpController.acceptChanges);

  app.del('/project/:project_id/doc/:doc_id/comment/:comment_id', HttpController.deleteComment);

  app.get('/flush_all_projects', HttpController.flushAllProjects);

  app.get('/flush_queued_projects', HttpController.flushQueuedProjects);

  // ? 加一个qs,表示version
  app.get('/RedisUpdated', async function(req, res) { // document-updater.background.consumer
    redis = require("redis-sharelatex");
    client = redis.createClient(Settings.redis.documentupdater);
    logger.log("zevin: RedisUpdated")
    if ((req.query != null ? req.query.v : undefined) != null) {
      version = parseInt(req.query.v, 10)
    } else{
      return res.status(400).send({body: 'no version specified.'});
    }
    // zevin: TDS1
    var TDS1 = process.hrtime();
    var msTDS1 = Date.now();
    var TD1,msTD1;
    logger.log({TDS1: TDS1[0]*1e9+TDS1[1], msTDS1: msTDS1}, 'Zevin: TDS1')
    return client.blpop("pending-updates-list", 1, async function(error, result) {
      var backgroundTask, doc_id, doc_key, list_name, project_id, _ref;
      logger.log("getting pending-updates-list", error, result);
      if (error != null) {
        return res.send(500)
      }
      if (result == null) {
        return res.send(404)
      }
      // zevin: TD1
      TD1 = process.hrtime();
      msTD1 = Date.now();
      logger.log({TD1: TD1[0]*1e9+TD1[1], msTD1: msTD1}, 'Zevin: TD1')
      list_name = result[0], doc_key = result[1];
      Keys = require('./app/js/UpdateKeys')
      _ref = Keys.splitProjectIdAndDocId(doc_key), project_id = _ref[0], doc_id = _ref[1];
      function backgroundTask(){
        return new Promise(function(resolve) {
          UpdateManager = require('./app/js/UpdateManager')
          UpdateManager.processOutstandingUpdatesWithLock(project_id, doc_id, function(error) {
            var logAsWarning;
            if (error != null) {
              logAsWarning = (error instanceof Errors.OpRangeNotAvailableError) || (error instanceof Errors.DeleteMismatchError);
              if (logAsWarning) {
                logger.warn({
                  err: error,
                  project_id: project_id,
                  doc_id: doc_id
                }, "error processing update");
              } else {
                logger.error({
                  err: error,
                  project_id: project_id,
                  doc_id: doc_id
                }, "error processing update");
                resolve({body: `error: ${error}`, statusCode: 500})
              }
            }
            logger.log('zevin line: 155')
            resolve({body: `redis updated: project_id:${project_id} , doc_id:${doc_id}`, statusCode: 200})
          })
        })
      }
      logger.log("zevin: getting pending-updates-list")
      const result1 = await backgroundTask();
      // zevin: TDS2
      var TDS2 = process.hrtime();
      var msTDS2 = Date.now();
      logger.log({TDS2: TDS2[0]*1e9+TDS2[1], msTDS2: msTDS2}, 'Zevin: TDS2')
      if (version == -1) {
        body = `hostname:${hostname},TDS1:${TDS1[0]*1e9+TDS1[1]},msTDS1:${msTDS1},TDS2:${TDS2[0]*1e9+TDS2[1]},msTDS2:${msTDS2}`;
        return res.status(result1.statusCode).send(body);
      }
      function sleep(ms) {	
        return new Promise((resolve) => {	
          setTimeout(resolve, ms);	
        });	
      }
      var i = 0;
      while (TDMap.ifMapNotExists('TD2') || TDMap.ifMapNotExists('msTD2')) {
        await sleep(1)
        i = i + 1
        if (i > 5000) {
          if (TDMap.ifMapNotExists('TD2')){
            logger.log('no TDMap[\'TD2\'] got', 'Zevin\'s 500')
            return res.status(500).send({body: `no TDMap[\'TD2\'] got; hostname:${hostname},TDS1:${TDS1[0]*1e9+TDS1[1]},msTDS1:${msTDS1},TDS2:${TDS2[0]*1e9+TDS2[1]},msTDS2:${msTDS2},TD1:${TD1[0]*1e9+TD1[1]},msTD1:${msTD1}`});
          }
          else {
            logger.log('no TDMap[\'msTD2\'] got', 'Zevin\'s 500')
            return res.status(500).send({body: `no TDMap[\'msTD2\'] got; hostname:${hostname},TDS1:${TDS1[0]*1e9+TDS1[1]},msTDS1:${msTDS1},TDS2:${TDS2[0]*1e9+TDS2[1]},msTDS2:${msTDS2},TD1:${TD1[0]*1e9+TD1[1]},msTD1:${msTD1}`});
          }
        }
      }
      i = 0;
      while (TDMap.ifValueNotExists('TD2', `${version}`) || TDMap.ifValueNotExists('msTD2', `${version}`)) {
        await sleep(1)
        i = i + 1
        if (i > 300) {
          if (TDMap.ifValueNotExists('TD2', `${version}`)){
            logger.log(`hostname:${hostname};no TDMap[\'TD2\'][${version}] got`, 'Zevin\'s 500')
            return res.status(500).send({body: `no TDMap[\'TD2\'][${version}] got; hostname:${hostname},TDS1:${TDS1[0]*1e9+TDS1[1]},msTDS1:${msTDS1},TDS2:${TDS2[0]*1e9+TDS2[1]},msTDS2:${msTDS2},TD1:${TD1[0]*1e9+TD1[1]},msTD1:${msTD1}`});
          }
          else{
            logger.log(`hostname:${hostname};no TDMap[\'msTD2\'][${version}] got`, 'Zevin\'s 500')
            return res.status(500).send({body: `no TDMap[\'msTD2\'][${version}] got; hostname:${hostname},TDS1:${TDS1[0]*1e9+TDS1[1]},msTDS1:${msTDS1},TDS2:${TDS2[0]*1e9+TDS2[1]},msTDS2:${msTDS2},TD1:${TD1[0]*1e9+TD1[1]},msTD1:${msTD1}`});
          }
        }
      }
      var i = 0;
      while (TDMap.ifMapNotExists('TD3') || TDMap.ifMapNotExists('msTD3')) {
        await sleep(1)
        i = i + 1
        if (i > 1000) {
          if (TDMap.ifMapNotExists('TD3')){
            logger.log('no TDMap[\'TD3\'] got', 'Zevin\'s 500')
            return res.status(500).send({body: `no TDMap[\'TD3\'] got; hostname:${hostname},TDS1:${TDS1[0]*1e9+TDS1[1]},msTDS1:${msTDS1},TDS2:${TDS2[0]*1e9+TDS2[1]},msTDS2:${msTDS2},TD1:${TD1[0]*1e9+TD1[1]},msTD1:${msTD1}`});
          }
          else {
            logger.log('no TDMap[\'msTD3\'] got', 'Zevin\'s 500')
            return res.status(500).send({body: `no TDMap[\'msTD3\'] got; hostname:${hostname},TDS1:${TDS1[0]*1e9+TDS1[1]},msTDS1:${msTDS1},TDS2:${TDS2[0]*1e9+TDS2[1]},msTDS2:${msTDS2},TD1:${TD1[0]*1e9+TD1[1]},msTD1:${msTD1}`});
          }
        }
      }
      i = 0;
      while (TDMap.ifValueNotExists('TD3', `${version}`) || TDMap.ifValueNotExists('msTD3', `${version}`)) {
        await sleep(1)
        i = i + 1
        if (i > 300) {
          if (TDMap.ifValueNotExists('TD3', `${version}`)){
            logger.log(`hostname:${hostname};no TDMap[\'TD3\'][${version}] got`, 'Zevin\'s 500')
            return res.status(500).send({body: `no TDMap[\'TD3\'][${version}] got; hostname:${hostname},TDS1:${TDS1[0]*1e9+TDS1[1]},msTDS1:${msTDS1},TDS2:${TDS2[0]*1e9+TDS2[1]},msTDS2:${msTDS2},TD1:${TD1[0]*1e9+TD1[1]},msTD1:${msTD1}`});
          }
          else{
            logger.log(`hostname:${hostname};no TDMap[\'msTD3\'][${version}] got`, 'Zevin\'s 500')
            return res.status(500).send({body: `no TDMap[\'msTD3\'][${version}] got; hostname:${hostname},TDS1:${TDS1[0]*1e9+TDS1[1]},msTDS1:${msTDS1},TDS2:${TDS2[0]*1e9+TDS2[1]},msTDS2:${msTDS2},TD1:${TD1[0]*1e9+TD1[1]},msTD1:${msTD1}`});
          }
        }
      }
      var TD2 = JSON.stringify(TDMap.getMap('TD2'));
      var msTD2 = JSON.stringify(TDMap.getMap('msTD2'));
      var TD3 = JSON.stringify(TDMap.getMap('TD3'));
      var msTD3 = JSON.stringify(TDMap.getMap('msTD3'));
      TDMap.deleteKey('TD2', `${version}`);
      TDMap.deleteKey('msTD2', `${version}`);
      TDMap.deleteKey('TD3', `${version}`);
      TDMap.deleteKey('msTD3', `${version}`);
      // var TD2 = TDMap.getValue('TD2', `${version}`);
      // var msTD2 = TDMap.getValue('msTD2', `${version}`);
      // var TD3 = TDMap.getValue('TD3', `${version}`);
      // var msTD3 = TDMap.getValue('msTD3', `${version}`);
      body = `hostname:${hostname},TDS1:${TDS1[0]*1e9+TDS1[1]},msTDS1:${msTDS1},TDS2:${TDS2[0]*1e9+TDS2[1]},msTDS2:${msTDS2},TD1:${TD1[0]*1e9+TD1[1]},msTD1:${msTD1},TD2:${TD2},msTD2:${msTD2},TD3:${TD3},msTD3:${msTD3}`;
      // body = `TDS1:${TDS1[0]*1e9+TDS1[1]},msTDS1:${msTDS1},TD1:${TD1[0]*1e9+TD1[1]},msTD1:${msTD1},TD2:${TD2},msTD2:${msTD2},TD3:${TD3},msTD3:${msTD3},TDS2:${TDS2[0]*1e9+TDS2[1]},msTDS2:${msTDS2}`;
      // body = {body: `Zevin: TDS1=${TDS1[0]*1e9+TDS1[1]};TD1=${TD1[0]*1e9+TD1[1]};TD3=${TD3};TD3opData=${TD3opData};TDS2=${TDS2[0]*1e9+TDS2[1]};`};
      // process.env['TD3'] = null;
      return res.status(result1.statusCode).send(body);
      // return res.status(result1.statusCode).send(result1.body);
    });
  })

  app.get('/total', function(req, res) {
    var timer;
    timer = new Metrics.Timer("http.allDocList");
    return RedisManager.getCountOfDocsInMemory(function(err, count) {
      timer.done();
      return res.send({
        total: count
      });
    });
  });

  app.get('/status', function(req, res) {
    if (Settings.shuttingDown) {
      return res.send(503);
    } else {
      return res.send('document updater is alive');
    }
  });

  pubsubClient = require("redis-sharelatex").createClient(Settings.redis.pubsub);

  app.get("/health_check/redis", function(req, res, next) {
    return pubsubClient.healthCheck(function(error) {
      if (error != null) {
        logger.err({
          err: error
        }, "failed redis health check");
        return res.send(500);
      } else {
        return res.send(200);
      }
    });
  });

  docUpdaterRedisClient = require("redis-sharelatex").createClient(Settings.redis.documentupdater);

  app.get("/health_check/redis_cluster", function(req, res, next) {
    return docUpdaterRedisClient.healthCheck(function(error) {
      if (error != null) {
        logger.err({
          err: error
        }, "failed redis cluster health check");
        return res.send(500);
      } else {
        return res.send(200);
      }
    });
  });

  app.get("/health_check", function(req, res, next) {
    return async.series([
      function(cb) {
        return pubsubClient.healthCheck(function(error) {
          if (error != null) {
            logger.err({
              err: error
            }, "failed redis health check");
          }
          return cb(error);
        });
      }, function(cb) {
        return docUpdaterRedisClient.healthCheck(function(error) {
          if (error != null) {
            logger.err({
              err: error
            }, "failed redis cluster health check");
          }
          return cb(error);
        });
      }, function(cb) {
        return mongojs.healthCheck(function(error) {
          if (error != null) {
            logger.err({
              err: error
            }, "failed mongo health check");
          }
          return cb(error);
        });
      }
    ], function(error) {
      if (error != null) {
        return res.send(500);
      } else {
        return res.send(200);
      }
    });
  });

  app.use(function(error, req, res, next) {
    if (error instanceof Errors.NotFoundError) {
      return res.send(404);
    } else if (error instanceof Errors.OpRangeNotAvailableError) {
      return res.send(422);
    } else if (error.statusCode === 413) {
      return res.send(413, "request entity too large");
    } else {
      logger.error({
        err: error,
        req: req
      }, "request errored");
      return res.send(500, "Oops, something went wrong");
    }
  });

  shutdownCleanly = function(signal) {
    return function() {
      logger.log({
        signal: signal
      }, "received interrupt, cleaning up");
      Settings.shuttingDown = true;
      return setTimeout(function() {
        logger.log({
          signal: signal
        }, "shutting down");
        return process.exit();
      }, 10000);
    };
  };

  watchForEvent = function(eventName) {
    return docUpdaterRedisClient.on(eventName, function(e) {
      return console.log("redis event: " + eventName + " " + e);
    });
  };

  events = ["connect", "ready", "error", "close", "reconnecting", "end"];

  for (_i = 0, _len = events.length; _i < _len; _i++) {
    eventName = events[_i];
    watchForEvent(eventName);
  }

  port = ((_ref1 = Settings.internal) != null ? (_ref2 = _ref1.documentupdater) != null ? _ref2.port : void 0 : void 0) || ((_ref3 = Settings.apis) != null ? (_ref4 = _ref3.documentupdater) != null ? _ref4.port : void 0 : void 0) || 3003;

  host = Settings.internal.documentupdater.host || "localhost";

  if (!module.parent) {
    app.listen(port, host, function() {
      logger.info("Document-updater starting up, listening on " + host + ":" + port);
      if (Settings.continuousBackgroundFlush) {
        logger.info("Starting continuous background flush");
        return DeleteQueueManager.startBackgroundFlush();
      }
    });
  }

  module.exports = app;  // document-updater.express.exports

  _ref5 = ['SIGINT', 'SIGHUP', 'SIGQUIT', 'SIGUSR1', 'SIGUSR2', 'SIGTERM', 'SIGABRT'];
  for (_j = 0, _len1 = _ref5.length; _j < _len1; _j++) {
    signal = _ref5[_j];
    process.on(signal, shutdownCleanly(signal));
  }

}).call(this);

//# sourceMappingURL=app.map
