// Generated by CoffeeScript 1.7.1
(function() {
  process.env["WEB_API_HOST"] = '172.17.0.1';
  process.env["WEB_HOST"] = '172.17.0.1';
  process.env["SHARELATEX_MONGO_URL"] = "mongodb://172.17.0.1/sharelatex";
  process.env["MONGO_HOST"] = '172.17.0.1';
  process.env["SHARELATEX_REDIS_HOST"] = '172.17.0.1';
  process.env["REDIS_HOST"] = '172.17.0.1';
  process.env["TAGS_HOST"] = '172.17.0.1';
  process.env["CLSI_HOST"] = '172.17.0.1';
  process.env["CHAT_HOST"] = '172.17.0.1';
  process.env["DOCSTORE_HOST"] = '172.17.0.1';
  process.env["SPELLING_HOST"] = '172.17.0.1';
  process.env["FILESTORE_HOST"] = '172.17.0.1';
  process.env["DOCUMENT_UPDATER_HOST"] = '172.17.0.1';
  process.env["NOTIFICATIONS_HOST"] = '172.17.0.1';
  process.env["CONTACTS_HOST"] = '172.17.0.1';
  process.env["LISTEN_ADDRESS"] = '0.0.0.0';
  process.env["REALTIME_HOST"] = '172.17.0.1';
  process.env["TRACK_CHANGES_HOST"] = '172.17.0.1';
  process.env["ENABLE_CONVERSIONS"] = 'true';
  process.env["WEB_API_USER"] = 'sharelatex';
  process.env["ENABLED_LINKED_FILE_TYPES"] = 'url;project_file';
  process.env["SHARELATEX_APP_NAME"] = 'Overleaf Community Edition';
  process.env["APP_NAME"] = 'Overleaf Community Edition';
  process.env["WEB_API_PASSWORD"] = 'rAp8aFvtk77m20PG6Kedzt3iOOrWKJ3pL5eiaQsP6s';
  process.env["SESSION_SECRET"] = 'K1pOaUSsFIoXADLUIgtIh4toKBzgoZS1vHRXNySWQc';
  process.env["SHARELATEX_SESSION_SECRET"] = 'K1pOaUSsFIoXADLUIgtIh4toKBzgoZS1vHRXNySWQc';
  process.env["SHARELATEX_CONFIG"] = __dirname + '/settings.coffee';
  process.env['WEB_URL'] = 'https://172.17.0.1/api/v1/web/guest/sharelatex/web'

  process.env['TRACKCHANGES_URL'] = 'https://172.17.0.1/api/v1/web/guest/sharelatex/track-changes'
  process.env['NODE_TLS_REJECT_UNAUTHORIZED']=0

  var DeleteQueueManager, DispatchManager, Errors, HttpController, Metrics, Path, RedisManager, Settings, app, async, docUpdaterRedisClient, eventName, events, express, host, http, logger, mongojs, port, pubsubClient, shutdownCleanly, signal, watchForEvent, _i, _j, _len, _len1, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
  
  const runmiddlewareFlag = false

  Metrics = require("metrics-sharelatex");

  Metrics.initialize("doc-updater");

  express = require('express');

  http = require("http");

  Settings = require('settings-sharelatex');

  logger = require('logger-sharelatex');

  logger.initialize("document-updater");

  logger.logger.addSerializers(require("./app/js/LoggerSerializers"));

  if (((_ref = Settings.sentry) != null ? _ref.dsn : void 0) != null) {
    logger.initializeErrorReporting(Settings.sentry.dsn);
  }

  RedisManager = require('./app/js/RedisManager');

  DispatchManager = require('./app/js/DispatchManager');

  DeleteQueueManager = require('./app/js/DeleteQueueManager');

  Errors = require("./app/js/Errors");

  HttpController = require("./app/js/HttpController");

  mongojs = require("./app/js/mongojs");

  async = require("async");

  Path = require("path");

  Metrics.mongodb.monitor(Path.resolve(__dirname + "/node_modules/mongojs/node_modules/mongodb"), logger);

  Metrics.event_loop.monitor(logger, 100);

  app = express();

  app.configure(function() {
    app.use(Metrics.http.monitor(logger));
    app.use(express.bodyParser({
      limit: Settings.max_doc_length + 64 * 1024
    }));
  
  app.use(function (req, res, next) {
    logger.error({
      err: req
    }, 'zevin\'s log')
    return next()
  });
    return app.use(app.router);
  });
  

  Metrics.injectMetricsRoute(app);

  app.param('project_id', function(req, res, next, project_id) {
    if (project_id != null ? project_id.match(/^[0-9a-f]{24}$/) : void 0) {
      return next();
    } else {
      return next(new Error("invalid project id"));
    }
  });

  app.param('doc_id', function(req, res, next, doc_id) {
    if (doc_id != null ? doc_id.match(/^[0-9a-f]{24}$/) : void 0) {
      return next();
    } else {
      return next(new Error("invalid doc id"));
    }
  });

  app.get('/project/:project_id/doc/:doc_id', HttpController.getDoc);

  app.get('/project/:project_id/doc', HttpController.getProjectDocsAndFlushIfOld);

  app.post('/project/:project_id/get_and_flush_if_old', HttpController.getProjectDocsAndFlushIfOld);

  app.post('/project/:project_id/clearState', HttpController.clearProjectState);

  app.post('/project/:project_id/doc/:doc_id', HttpController.setDoc);

  app.post('/project/:project_id/doc/:doc_id/flush', HttpController.flushDocIfLoaded);

  app["delete"]('/project/:project_id/doc/:doc_id', HttpController.flushAndDeleteDoc);

  app["delete"]('/project/:project_id', HttpController.deleteProject);

  app["delete"]('/project', HttpController.deleteMultipleProjects);

  app.post('/project/:project_id', HttpController.updateProject);

  app.post('/project/:project_id/history/resync', HttpController.resyncProjectHistory);

  app.post('/project/:project_id/flush', HttpController.flushProject);

  app.post('/project/:project_id/doc/:doc_id/change/:change_id/accept', HttpController.acceptChanges);

  app.post('/project/:project_id/doc/:doc_id/change/accept', HttpController.acceptChanges);

  app.del('/project/:project_id/doc/:doc_id/comment/:comment_id', HttpController.deleteComment);

  app.get('/flush_all_projects', HttpController.flushAllProjects);

  app.get('/flush_queued_projects', HttpController.flushQueuedProjects);

  app.get('/total', function(req, res) {
    var timer;
    timer = new Metrics.Timer("http.allDocList");
    return RedisManager.getCountOfDocsInMemory(function(err, count) {
      timer.done();
      return res.send({
        total: count
      });
    });
  });

  app.get('/status', function(req, res) {
    if (Settings.shuttingDown) {
      return res.send(503);
    } else {
      return res.send('document updater is alive');
    }
  });

  pubsubClient = require("redis-sharelatex").createClient(Settings.redis.pubsub);

  app.get("/health_check/redis", function(req, res, next) {
    return pubsubClient.healthCheck(function(error) {
      if (error != null) {
        logger.err({
          err: error
        }, "failed redis health check");
        return res.send(500);
      } else {
        return res.send(200);
      }
    });
  });

  docUpdaterRedisClient = require("redis-sharelatex").createClient(Settings.redis.documentupdater);

  app.get("/health_check/redis_cluster", function(req, res, next) {
    return docUpdaterRedisClient.healthCheck(function(error) {
      if (error != null) {
        logger.err({
          err: error
        }, "failed redis cluster health check");
        return res.send(500);
      } else {
        return res.send(200);
      }
    });
  });

  app.get("/health_check", function(req, res, next) {
    return async.series([
      function(cb) {
        return pubsubClient.healthCheck(function(error) {
          if (error != null) {
            logger.err({
              err: error
            }, "failed redis health check");
          }
          return cb(error);
        });
      }, function(cb) {
        return docUpdaterRedisClient.healthCheck(function(error) {
          if (error != null) {
            logger.err({
              err: error
            }, "failed redis cluster health check");
          }
          return cb(error);
        });
      }, function(cb) {
        return mongojs.healthCheck(function(error) {
          if (error != null) {
            logger.err({
              err: error
            }, "failed mongo health check");
          }
          return cb(error);
        });
      }
    ], function(error) {
      if (error != null) {
        return res.send(500);
      } else {
        return res.send(200);
      }
    });
  });

  app.use(function(error, req, res, next) {
    if (error instanceof Errors.NotFoundError) {
      return res.send(404);
    } else if (error instanceof Errors.OpRangeNotAvailableError) {
      return res.send(422);
    } else if (error.statusCode === 413) {
      return res.send(413, "request entity too large");
    } else {
      logger.error({
        err: error,
        req: req
      }, "request errored");
      return res.send(500, "Oops, something went wrong");
    }
  });

  shutdownCleanly = function(signal) {
    return function() {
      logger.log({
        signal: signal
      }, "received interrupt, cleaning up");
      Settings.shuttingDown = true;
      return setTimeout(function() {
        logger.log({
          signal: signal
        }, "shutting down");
        return process.exit();
      }, 10000);
    };
  };

  watchForEvent = function(eventName) {
    return docUpdaterRedisClient.on(eventName, function(e) {
      return console.log("redis event: " + eventName + " " + e);
    });
  };

  events = ["connect", "ready", "error", "close", "reconnecting", "end"];

  for (_i = 0, _len = events.length; _i < _len; _i++) {
    eventName = events[_i];
    watchForEvent(eventName);
  }

  port = ((_ref1 = Settings.internal) != null ? (_ref2 = _ref1.documentupdater) != null ? _ref2.port : void 0 : void 0) || ((_ref3 = Settings.apis) != null ? (_ref4 = _ref3.documentupdater) != null ? _ref4.port : void 0 : void 0) || 3003;

  host = Settings.internal.documentupdater.host || "localhost";

    app.listen(port, host, function() {
      logger.info("Document-updater starting up, listening on " + host + ":" + port);
      if (Settings.continuousBackgroundFlush) {
        logger.info("Starting continuous background flush");
        return DeleteQueueManager.startBackgroundFlush();
      }
    });

      
  module.exports.main = test;

  _ref5 = ['SIGINT', 'SIGHUP', 'SIGQUIT', 'SIGUSR1', 'SIGUSR2', 'SIGTERM', 'SIGABRT'];
  for (_j = 0, _len1 = _ref5.length; _j < _len1; _j++) {
    signal = _ref5[_j];
    process.on(signal, shutdownCleanly(signal));
  };
	function sleep(ms) {
    	return new Promise((resolve) => {
      	setTimeout(resolve, ms);
    	}); 
  }

  async function test(params = {}) {
    const {promisify} = require("util"); 
    const request = require("request");
    const operation = params.operation || "RedisUpdated"
       //"getDoc"
     //console.log("outPut test")
    const opts = { timeout: 1000 * 20 }
      project_id = params.project_id ||"5ecf0cb75f735b007489e9e8";
      doc_id = params.doc_id || "5ecf0cb75f735b007489e9e9";
    if(operation === "RedisUpdated")
    {
      
      DispatchManager.createAndStartDispatchers(Settings.dispatcherCount || 10);
      await sleep(2000);    
      return {body:"OK"};
    }
    else if (operation === "getDoc") {
      opts.url = `http://localhost:3003/project/${project_id}/doc/${doc_id}`;
      const getReq = promisify(request.get);
        
						console.log("Now got the result");
      return (async () => {
        let result = await getReq(opts);
						console.log("Now got the result");
        let body = result.body;
        
        return { result:  body };
      })();
    }
    else if(operation === "getProjectDocsAndFlushIfOld1")
    {
      opts.url = `http://localhost:3003/project/${project_id}/doc`;
      const getReq = promisify(request.get); 
      return (async () => {
        let result = await getReq(opts);
        let body = result.body;
        let statusCode = result.statusCode;
        if (statusCode == 409)
        {
          return { result: { message: `error processing ${operation} request`, status: "failed" } };
        }
        return { result:  body };
      })();
    }
    else if (operation === "getProjectDocsAndFlushIfOld2") {
      opts.url = `http://localhost:3003/project/${project_id}/get_and_flush_if_old`;
      const postReq = promisify(request.post);
      return (async () => {
        let result = await postReq(opts);
        let statusCode = result.statusCode;
        if (statusCode == 500) {
          return { result: { message: `error processing ${operation} request`, status: "failed", statusCode } };
        }
        return { status: "passed"} 
      })();
    }
    else if (operation === "clearState") {
      opts.url = `http://localhost:3003/project/${project_id}/clearState`;
      const postReq = promisify(request.post);
  
      return (async () => {
        let result = await postReq(opts);
        let statusCode = result.statusCode;
        if (statusCode == 500) {
          return { result: { message: `error processing ${operation} request`, status: "failed" }, statusCode };
        }
        // return {result: {words:result.body}}
        return { status: "passed", statusCode } ;
      })();
    }
    else if(operation === "setDoc")
    {
      //app.post('/project/${project_id}/doc/:doc_id', HttpController.setDoc);
      opts.url = `http://localhost:3003/project/${project_id}/doc/${doc_id}'`;
      const postReq = promisify(request.post);
  
      return (async () => {
        let result = await postReq(opts);
        let statusCode = result.statusCode;
        if (statusCode === 204) {
          return { result: { message: `success processing ${operation} request`, status: "success" }, statusCode };
        }
        return { message: "ERROR", status: "Failed", statusCode  };
      })();
    }
    else if (operation === "status") {
      opts.url = `http://localhost:3003/status`;
      const getReq = promisify(request.get);
  
      return (async () => {
        let result = await getReq(opts);
        let statusCode = result.statusCode;
        if (statusCode == 500) {
          return { result: { message: `error processing ${operation} request`, status: "failed" }, statusCode };
        }
        return { result: { message: "up", status: "passed", statusCode } };
      })();
    }
    else if (operation === "healthCheck") {
      opts.url = `http://localhost:3003/health_check`;
      const getReq = promisify(request.get);
  
      return (async () => {
        let result = await getReq(opts);
        let statusCode = result.statusCode;
        if (statusCode == 500) {
          return { result: { message: "health check failed", status: "failed" } };
        }
        return { result: { message: "health check passed", status: "passed", statusCode } };
      })();
    }
    else if (operation === "flushDocIfLoaded")
    {
      //app.post('/project/${project_id}/doc/:doc_id/flush', HttpController.)
      opts.url = `http://localhost:3003/project/${project_id}/doc/${doc_id}/flush`
      const postReq = promisify(request.post);
      return (async () => {
        let result = await postReq(opts);
        let statusCode = result.statusCode;
        if (statusCode == 500) {
          return { result: { message: `error processing ${operation} request`, status: "failed" } };
        }
        // return {result: {words:result.body}}
        return { status: "passed", message:"flushed doc via http" } ;
      })();
    }
    else if(operation === "updateProject")
    {
      //app.post('/project/${project_id}', HttpController.updateProject);
      opts.url = `http://localhost:3003/project/${project_id}`
      const postReq = promisify(request.post);
      return (async () => {
        let result = await postReq(opts);
        let statusCode = result.statusCode;
        if (statusCode == 500) {
          return { result: { message: `error processing ${operation} request`, status: "failed" }, statusCode };
        }
        // return {result: {words:result.body}}
        return { status: "passed", statusCode } ;
      })();
    }
    else if(operation === "flushProject")
    {
      //app.post('/project/${project_id}/flush', HttpController.flushProject);
      opts.url = `http://localhost:3003/project/${project_id}/flush`
      const postReq = promisify(request.post);
      return (async () => {
        let result = await postReq(opts);
        let statusCode = result.statusCode;
        if (statusCode == 500) {
          return { result: { message: `error processing ${operation} request`, status: "failed" }, statusCode };
        }
        // return {result: {words:result.body}}
        return { status: "passed", statusCode } ;
      })();
    }
    else if(operation === "resyncProjectHistory")
    {
      //app.post('/project/${project_id}/history/resync', HttpController.resyncProjectHistory);
      opts.url = `http://localhost:3003/project/${project_id}/history/resync`
      const postReq = promisify(request.post);
      return (async () => {
        let result = await postReq(opts);
        let statusCode = result.statusCode;
        if (statusCode == 500) {
          return { result: { message: `error processing ${operation} request`, status: "failed" }, statusCode };
        }
        // return {result: {words:result.body}}
        return { status: "passed", statusCode } ;
      })();
    }
    else if(operation === "flushAndDeleteDoc")
    {
      //app["delete"]('/project/${project_id}/doc/:doc_id', HttpController.flushAndDeleteDoc);
      opts.url = `http://localhost:3003/project/${project_id}/doc/${doc_id}`
      const delReq = promisify(request.del);
      return (async () => {
        let result = await delReq(opts);
        let statusCode = result.statusCode;
        if (statusCode == 500) {
          return { result: { message: `error processing ${operation} request`, status: "failed" }, statusCode };
        }
        // return {result: {words:result.body}}
        return { status: "passed", statusCode } ;
      })();
    }
    else if(operation === "deleteProject")
    {
      //app["delete"]('/project/${project_id}', HttpController.deleteProject)
      opts.url = `http://localhost:3003/project/${project_id}`
      const delReq = promisify(request.del);
      return (async () => {
        let result = await delReq(opts);
        let statusCode = result.statusCode;
        if (statusCode == 500) {
          return { result: { message: `error processing ${operation} request`, status: "failed" }, statusCode };
        }
        // return {result: {words:result.body}}
        return { status: "passed", statusCode } ;
      })();
    }
    else if(operation === "healthCheckRedis")
    {	
      opts.url = `http://localhost:3003/health_check/redis_cluster`;
      const getReq = promisify(request.get);
      return (async () => {
        let result = await getReq(opts);
        let statusCode = result.statusCode;
        if (statusCode == 500) {
          return { result: { message: `error processing ${operation} request`, status: "failed" }, statusCode };
        }
        return { status: "passed", statusCode }
      })();

    }
    else
    {
      return {message: "unknown operations"}
    }
  }

  if(!module.parent){
    (async ()=>{
      const a = await test();
      console.log(a);
    })();
  }

}).call(this);

//# sourceMappingURL=app.map
